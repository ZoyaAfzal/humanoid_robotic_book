"use strict";(globalThis.webpackChunkhumanoid_robotic_book=globalThis.webpackChunkhumanoid_robotic_book||[]).push([[443],{81:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>u,contentTitle:()=>l,default:()=>g,frontMatter:()=>r,metadata:()=>s,toc:()=>c});var o=a(8168),i=(a(6540),a(5680)),t=a(299);const r={sidebar_position:1},l=void 0,s={unversionedId:"chapter3/lesson1/gazebo-environment-setup",id:"chapter3/lesson1/gazebo-environment-setup",title:"gazebo-environment-setup",description:"In this comprehensive lesson, you'll learn how to set up and configure Gazebo, the premier 3D robotics simulation environment. Gazebo provides realistic physics simulation, high-quality graphics, and sensor simulation capabilities essential for humanoid robot development and testing.",source:"@site/docs/chapter3/lesson1/gazebo-environment-setup.mdx",sourceDirName:"chapter3/lesson1",slug:"/chapter3/lesson1/gazebo-environment-setup",permalink:"/humanoid_robotic_book/docs/chapter3/lesson1/gazebo-environment-setup",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"mySidebar",previous:{title:"index",permalink:"/humanoid_robotic_book/docs/chapter3/"},next:{title:"simulating-physics-collisions",permalink:"/humanoid_robotic_book/docs/chapter3/lesson2/simulating-physics-collisions"}},u={},c=[{value:"Introduction to Gazebo",id:"introduction-to-gazebo",level:2},{value:"Key Features of Gazebo",id:"key-features-of-gazebo",level:3},{value:"Installing and Configuring Gazebo",id:"installing-and-configuring-gazebo",level:2},{value:"System Requirements",id:"system-requirements",level:3},{value:"Installation Process",id:"installation-process",level:3},{value:"Method 1: Package Installation (Recommended)",id:"method-1-package-installation-recommended",level:4},{value:"Method 2: Using ROS 2 Integration",id:"method-2-using-ros-2-integration",level:4},{value:"Verification and Basic Setup",id:"verification-and-basic-setup",level:3},{value:"Gazebo World Creation and Configuration",id:"gazebo-world-creation-and-configuration",level:2},{value:"World File Structure",id:"world-file-structure",level:3},{value:"Creating Custom Environments",id:"creating-custom-environments",level:3},{value:"Gazebo Plugins for Humanoid Robots",id:"gazebo-plugins-for-humanoid-robots",level:2},{value:"ROS 2 Control Integration",id:"ros-2-control-integration",level:3},{value:"Sensor Plugins",id:"sensor-plugins",level:3},{value:"Camera Sensor Plugin",id:"camera-sensor-plugin",level:4},{value:"IMU Sensor Plugin",id:"imu-sensor-plugin",level:4},{value:"Launching Gazebo with Your Robot",id:"launching-gazebo-with-your-robot",level:2},{value:"Creating a Launch File",id:"creating-a-launch-file",level:3},{value:"Advanced Gazebo Configuration for Humanoid Robots",id:"advanced-gazebo-configuration-for-humanoid-robots",level:2},{value:"Physics Tuning",id:"physics-tuning",level:3},{value:"Collision and Friction Settings",id:"collision-and-friction-settings",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"GPU Acceleration",id:"gpu-acceleration",level:3},{value:"Optimizing Complex Models",id:"optimizing-complex-models",level:3},{value:"Troubleshooting Common Issues",id:"troubleshooting-common-issues",level:2},{value:"1. Robot Falls Through Ground",id:"1-robot-falls-through-ground",level:3},{value:"2. Unstable Walking Simulation",id:"2-unstable-walking-simulation",level:3},{value:"3. Slow Performance",id:"3-slow-performance",level:3},{value:"Best Practices for Humanoid Robot Simulation",id:"best-practices-for-humanoid-robot-simulation",level:2},{value:"1. Model Accuracy",id:"1-model-accuracy",level:3},{value:"2. Sensor Simulation",id:"2-sensor-simulation",level:3},{value:"3. Environment Design",id:"3-environment-design",level:3},{value:"4. Validation Process",id:"4-validation-process",level:3},{value:"Hands-on Exercise",id:"hands-on-exercise",level:2},{value:"Quiz Questions",id:"quiz-questions",level:2}],m={toc:c},d="wrapper";function g({components:e,...n}){return(0,i.yg)(d,(0,o.A)({},m,n,{components:e,mdxType:"MDXLayout"}),(0,i.yg)(t.A,{title:"Gazebo Environment Setup",chapter:3,lesson:1,mdxType:"InteractiveLesson"},(0,i.yg)("h1",{id:"gazebo-environment-setup"},"Gazebo Environment Setup"),(0,i.yg)("p",null,"In this comprehensive lesson, you'll learn how to set up and configure Gazebo, the premier 3D robotics simulation environment. Gazebo provides realistic physics simulation, high-quality graphics, and sensor simulation capabilities essential for humanoid robot development and testing."),(0,i.yg)("h2",{id:"introduction-to-gazebo"},"Introduction to Gazebo"),(0,i.yg)("p",null,"Gazebo is a powerful, open-source 3D robotics simulator that provides realistic physics simulation, high-quality graphics, and sensor simulation capabilities. For humanoid robotics, Gazebo serves as a digital twin environment where you can:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Test robot behaviors in safe, controlled conditions"),(0,i.yg)("li",{parentName:"ul"},"Validate control algorithms before real-world deployment"),(0,i.yg)("li",{parentName:"ul"},"Simulate complex interactions with the environment"),(0,i.yg)("li",{parentName:"ul"},"Generate synthetic training data for AI models"),(0,i.yg)("li",{parentName:"ul"},"Perform regression testing for robot software")),(0,i.yg)("h3",{id:"key-features-of-gazebo"},"Key Features of Gazebo"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("strong",{parentName:"li"},"Physics Simulation"),": Accurate simulation of rigid body dynamics, collisions, and contacts"),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("strong",{parentName:"li"},"Sensor Simulation"),": Realistic simulation of cameras, LiDAR, IMU, and other sensors"),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("strong",{parentName:"li"},"Environment Modeling"),": Creation of complex indoor and outdoor environments"),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("strong",{parentName:"li"},"ROS Integration"),": Seamless integration with ROS and ROS 2 for robot control"),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("strong",{parentName:"li"},"Plugin Architecture"),": Extensible system for custom sensors, controllers, and behaviors")),(0,i.yg)("h2",{id:"installing-and-configuring-gazebo"},"Installing and Configuring Gazebo"),(0,i.yg)("h3",{id:"system-requirements"},"System Requirements"),(0,i.yg)("p",null,"Before installing Gazebo, ensure your system meets the following requirements:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"Operating System"),": Ubuntu 20.04 LTS or 22.04 LTS (recommended)"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"Graphics"),": OpenGL 2.1+ compatible GPU with dedicated VRAM"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"RAM"),": Minimum 8GB (16GB recommended for complex simulations)"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"Storage"),": 5GB+ free space for Gazebo and models"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"CPU"),": Multi-core processor for optimal performance")),(0,i.yg)("h3",{id:"installation-process"},"Installation Process"),(0,i.yg)("p",null,"Gazebo can be installed in several ways depending on your needs:"),(0,i.yg)("h4",{id:"method-1-package-installation-recommended"},"Method 1: Package Installation (Recommended)"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-bash"},"# Update package lists\nsudo apt update\n\n# Install Gazebo (for Ubuntu 22.04, installs Gazebo Garden)\nsudo apt install gazebo\n\n# Install ROS 2 Gazebo packages\nsudo apt install ros-humble-gazebo-ros-pkgs ros-humble-gazebo-ros2-control\n\n# Install additional useful packages\nsudo apt install gazebo-plugin-base libgazebo-dev\n")),(0,i.yg)("h4",{id:"method-2-using-ros-2-integration"},"Method 2: Using ROS 2 Integration"),(0,i.yg)("p",null,"If you're using ROS 2 Humble Hawksbill, install the Gazebo integration packages:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-bash"},"# Install Gazebo simulation packages\nsudo apt install ros-humble-gazebo-*\n")),(0,i.yg)("h3",{id:"verification-and-basic-setup"},"Verification and Basic Setup"),(0,i.yg)("p",null,"After installation, verify Gazebo is working:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-bash"},"# Launch Gazebo GUI\ngazebo\n\n# Or launch without GUI for headless simulation\ngz sim -s\n\n# Check Gazebo version\ngz --version\n")),(0,i.yg)("h2",{id:"gazebo-world-creation-and-configuration"},"Gazebo World Creation and Configuration"),(0,i.yg)("h3",{id:"world-file-structure"},"World File Structure"),(0,i.yg)("p",null,"Gazebo worlds are defined using SDF (Simulation Description Format) files. Here's a basic world file structure:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-xml"},'<?xml version="1.0" ?>\n<sdf version="1.7">\n  <world name="humanoid_robot_world">\n    \x3c!-- Include default atmosphere --\x3e\n    <include>\n      <uri>model://sun</uri>\n    </include>\n\n    \x3c!-- Include ground plane --\x3e\n    <include>\n      <uri>model://ground_plane</uri>\n    </include>\n\n    \x3c!-- Lighting configuration --\x3e\n    <light name="sun" type="directional">\n      <cast_shadows>true</cast_shadows>\n      <pose>0 0 10 0 0 0</pose>\n      <diffuse>0.8 0.8 0.8 1</diffuse>\n      <specular>0.2 0.2 0.2 1</specular>\n      <attenuation>\n        <range>1000</range>\n        <constant>0.9</constant>\n        <linear>0.01</linear>\n        <quadratic>0.001</quadratic>\n      </attenuation>\n      <direction>-0.5 0.1 -0.9</direction>\n    </light>\n\n    \x3c!-- Physics engine configuration --\x3e\n    <physics name="1ms" type="ignored">\n      <max_step_size>0.001</max_step_size>\n      <real_time_factor>1</real_time_factor>\n      <real_time_update_rate>1000</real_time_update_rate>\n    </physics>\n\n    \x3c!-- Environment models --\x3e\n    <model name="table">\n      <pose>2 0 0.5 0 0 0</pose>\n      <include>\n        <uri>model://table</uri>\n      </include>\n    </model>\n\n    \x3c!-- Your robot will be spawned here --\x3e\n  </world>\n</sdf>\n')),(0,i.yg)("h3",{id:"creating-custom-environments"},"Creating Custom Environments"),(0,i.yg)("p",null,"For humanoid robot simulation, you'll often need custom environments. Here's a more complex world file for humanoid testing:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-xml"},'<?xml version="1.0" ?>\n<sdf version="1.7">\n  <world name="humanoid_test_world">\n    \x3c!-- Atmosphere --\x3e\n    <include>\n      <uri>model://sun</uri>\n    </include>\n\n    \x3c!-- Ground plane with texture --\x3e\n    <include>\n      <uri>model://ground_plane</uri>\n    </include>\n\n    \x3c!-- Lighting --\x3e\n    <light name="main_light" type="directional">\n      <pose>0 0 10 0 0 0</pose>\n      <diffuse>0.8 0.8 0.8 1</diffuse>\n      <specular>0.2 0.2 0.2 1</specular>\n      <direction>-0.5 0.1 -0.9</direction>\n    </light>\n\n    \x3c!-- Physics configuration for humanoid simulation --\x3e\n    <physics name="humanoid_physics" type="ode">\n      <max_step_size>0.001</max_step_size>\n      <real_time_factor>1.0</real_time_factor>\n      <real_time_update_rate>1000</real_time_update_rate>\n      <gravity>0 0 -9.8</gravity>\n      <ode>\n        <solver>\n          <type>quick</type>\n          <iters>10</iters>\n          <sor>1.3</sor>\n        </solver>\n        <constraints>\n          <cfm>0.0</cfm>\n          <erp>0.2</erp>\n          <contact_max_correcting_vel>100.0</contact_max_correcting_vel>\n          <contact_surface_layer>0.001</contact_surface_layer>\n        </constraints>\n      </ode>\n    </physics>\n\n    \x3c!-- Environment obstacles for testing --\x3e\n    <model name="obstacle_1">\n      <pose>-2 0 0.5 0 0 0</pose>\n      <link name="link">\n        <collision name="collision">\n          <geometry>\n            <box>\n              <size>1 0.2 1</size>\n            </box>\n          </geometry>\n        </collision>\n        <visual name="visual">\n          <geometry>\n            <box>\n              <size>1 0.2 1</size>\n            </box>\n          </geometry>\n          <material>\n            <ambient>0.5 0.5 0.5 1</ambient>\n            <diffuse>0.8 0.8 0.8 1</diffuse>\n          </material>\n        </visual>\n        <pose>0 0 0.5 0 0 0</pose>\n      </link>\n    </model>\n\n    \x3c!-- Indoor environment elements --\x3e\n    <model name="wall_1">\n      <pose>0 -3 1 0 0 0</pose>\n      <link name="wall_link">\n        <collision name="wall_collision">\n          <geometry>\n            <box>\n              <size>6 0.2 2</size>\n            </box>\n          </geometry>\n        </collision>\n        <visual name="wall_visual">\n          <geometry>\n            <box>\n              <size>6 0.2 2</size>\n            </box>\n          </geometry>\n          <material>\n            <ambient>0.7 0.7 0.7 1</ambient>\n            <diffuse>0.9 0.9 0.9 1</diffuse>\n          </material>\n        </visual>\n      </link>\n    </model>\n\n    \x3c!-- Furniture for realistic environment --\x3e\n    <include>\n      <name>desk</name>\n      <pose>3 2 0 0 0 0</pose>\n      <uri>model://table</uri>\n    </include>\n\n    <include>\n      <name>chair</name>\n      <pose>3.5 2.5 0 0 0 1.57</pose>\n      <uri>model://chair</uri>\n    </include>\n  </world>\n</sdf>\n')),(0,i.yg)("h2",{id:"gazebo-plugins-for-humanoid-robots"},"Gazebo Plugins for Humanoid Robots"),(0,i.yg)("h3",{id:"ros-2-control-integration"},"ROS 2 Control Integration"),(0,i.yg)("p",null,"To integrate your humanoid robot with ROS 2, you'll need the Gazebo ROS 2 control plugin:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-xml"},'\x3c!-- In your robot\'s URDF/Xacro file --\x3e\n<gazebo>\n  <plugin filename="libgazebo_ros2_control.so" name="gazebo_ros2_control">\n    <parameters>$(find your_robot_description)/config/your_robot_controllers.yaml</parameters>\n    <robot_param>robot_description</robot_param>\n    <robot_param_node>robot_state_publisher</robot_param_node>\n  </plugin>\n</gazebo>\n')),(0,i.yg)("h3",{id:"sensor-plugins"},"Sensor Plugins"),(0,i.yg)("p",null,"Gazebo provides various sensor plugins for humanoid robots:"),(0,i.yg)("h4",{id:"camera-sensor-plugin"},"Camera Sensor Plugin"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-xml"},'<gazebo reference="camera_link">\n  <sensor name="camera" type="camera">\n    <update_rate>30</update_rate>\n    <camera name="head">\n      <horizontal_fov>1.047</horizontal_fov>\n      <image>\n        <width>640</width>\n        <height>480</height>\n        <format>R8G8B8</format>\n      </image>\n      <clip>\n        <near>0.1</near>\n        <far>100</far>\n      </clip>\n    </camera>\n    <plugin name="camera_controller" filename="libgazebo_ros_camera.so">\n      <frame_name>camera_optical_frame</frame_name>\n      <min_depth>0.1</min_depth>\n      <max_depth>100</max_depth>\n    </plugin>\n  </sensor>\n</gazebo>\n')),(0,i.yg)("h4",{id:"imu-sensor-plugin"},"IMU Sensor Plugin"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-xml"},'<gazebo reference="imu_link">\n  <sensor name="imu_sensor" type="imu">\n    <always_on>true</always_on>\n    <update_rate>100</update_rate>\n    <visualize>true</visualize>\n    <imu>\n      <angular_velocity>\n        <x>\n          <noise type="gaussian">\n            <mean>0.0</mean>\n            <stddev>0.0017</stddev>\n          </noise>\n        </x>\n        <y>\n          <noise type="gaussian">\n            <mean>0.0</mean>\n            <stddev>0.0017</stddev>\n          </noise>\n        </y>\n        <z>\n          <noise type="gaussian">\n            <mean>0.0</mean>\n            <stddev>0.0017</stddev>\n          </noise>\n        </z>\n      </angular_velocity>\n      <linear_acceleration>\n        <x>\n          <noise type="gaussian">\n            <mean>0.0</mean>\n            <stddev>0.017</stddev>\n          </noise>\n        </x>\n        <y>\n          <noise type="gaussian">\n            <mean>0.0</mean>\n            <stddev>0.017</stddev>\n          </noise>\n        </y>\n        <z>\n          <noise type="gaussian">\n            <mean>0.0</mean>\n            <stddev>0.017</stddev>\n          </noise>\n        </z>\n      </linear_acceleration>\n    </imu>\n  </sensor>\n  <plugin name="imu_plugin" filename="libgazebo_ros_imu.so">\n    <frame_name>imu_link</frame_name>\n    <topic>imu/data</topic>\n    <serviceName>imu/service</serviceName>\n    <gaussianNoise>0.01</gaussianNoise>\n    <updateRateHZ>100.0</updateRateHZ>\n  </plugin>\n</gazebo>\n')),(0,i.yg)("h2",{id:"launching-gazebo-with-your-robot"},"Launching Gazebo with Your Robot"),(0,i.yg)("h3",{id:"creating-a-launch-file"},"Creating a Launch File"),(0,i.yg)("p",null,"Here's a comprehensive launch file to start Gazebo with your humanoid robot:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},"import os\nfrom launch import LaunchDescription\nfrom launch.actions import DeclareLaunchArgument, IncludeLaunchDescription, ExecuteProcess\nfrom launch.conditions import IfCondition\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\nfrom launch.substitutions import LaunchConfiguration, PathJoinSubstitution\nfrom launch_ros.actions import Node\nfrom launch_ros.substitutions import FindPackageShare\n\ndef generate_launch_description():\n    # Launch configuration variables\n    use_sim_time = LaunchConfiguration('use_sim_time')\n    use_rviz = LaunchConfiguration('use_rviz')\n    world = LaunchConfiguration('world')\n\n    # Declare launch arguments\n    declare_use_sim_time_cmd = DeclareLaunchArgument(\n        'use_sim_time',\n        default_value='true',\n        description='Use simulation (Gazebo) clock if true'\n    )\n\n    declare_use_rviz_cmd = DeclareLaunchArgument(\n        'use_rviz',\n        default_value='true',\n        description='Whether to start RViz'\n    )\n\n    declare_world_cmd = DeclareLaunchArgument(\n        'world',\n        default_value=PathJoinSubstitution([\n            FindPackageShare('your_robot_gazebo'),\n            'worlds',\n            'humanoid_test_world.sdf'\n        ]),\n        description='Choose one of the world files from `/your_robot_gazebo/worlds`'\n    )\n\n    # Start Gazebo with specified world\n    start_gazebo_cmd = ExecuteProcess(\n        cmd=['gz', 'sim', '-r', '-v4', LaunchConfiguration('world')],\n        output='screen'\n    )\n\n    # Robot State Publisher\n    robot_state_publisher_cmd = Node(\n        package='robot_state_publisher',\n        executable='robot_state_publisher',\n        name='robot_state_publisher',\n        output='screen',\n        parameters=[{'use_sim_time': use_sim_time}]\n    )\n\n    # Spawn robot in Gazebo\n    spawn_entity_cmd = Node(\n        package='gazebo_ros',\n        executable='spawn_entity.py',\n        arguments=[\n            '-topic', 'robot_description',\n            '-entity', 'humanoid_robot',\n            '-x', '0.0',\n            '-y', '0.0',\n            '-z', '1.0'\n        ],\n        output='screen'\n    )\n\n    # RViz node\n    rviz_cmd = Node(\n        package='rviz2',\n        executable='rviz2',\n        name='rviz2',\n        output='screen',\n        parameters=[{'use_sim_time': use_sim_time}],\n        condition=IfCondition(use_rviz)\n    )\n\n    # Create launch description\n    ld = LaunchDescription()\n\n    # Add launch arguments\n    ld.add_action(declare_use_sim_time_cmd)\n    ld.add_action(declare_use_rviz_cmd)\n    ld.add_action(declare_world_cmd)\n\n    # Add launch actions\n    ld.add_action(start_gazebo_cmd)\n    ld.add_action(robot_state_publisher_cmd)\n    ld.add_action(spawn_entity_cmd)\n    ld.add_action(rviz_cmd)\n\n    return ld\n")),(0,i.yg)("h2",{id:"advanced-gazebo-configuration-for-humanoid-robots"},"Advanced Gazebo Configuration for Humanoid Robots"),(0,i.yg)("h3",{id:"physics-tuning"},"Physics Tuning"),(0,i.yg)("p",null,"For stable humanoid simulation, fine-tune physics parameters:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-xml"},'<physics name="humanoid_stable_physics" type="ode">\n  <max_step_size>0.001</max_step_size>\n  <real_time_factor>1.0</real_time_factor>\n  <real_time_update_rate>1000</real_time_update_rate>\n  <gravity>0 0 -9.8</gravity>\n  <ode>\n    <solver>\n      <type>quick</type>\n      <iters>100</iters>  \x3c!-- More iterations for stability --\x3e\n      <sor>1.3</sor>\n    </solver>\n    <constraints>\n      <cfm>0.000001</cfm>  \x3c!-- Constraint Force Mixing --\x3e\n      <erp>0.1</erp>      \x3c!-- Error Reduction Parameter --\x3e\n      <contact_max_correcting_vel>100.0</contact_max_correcting_vel>\n      <contact_surface_layer>0.001</contact_surface_layer>\n    </constraints>\n  </ode>\n</physics>\n')),(0,i.yg)("h3",{id:"collision-and-friction-settings"},"Collision and Friction Settings"),(0,i.yg)("p",null,"Proper collision and friction settings are crucial for humanoid walking:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-xml"},'\x3c!-- In your robot\'s URDF --\x3e\n<gazebo reference="left_foot">\n  <collision>\n    <max_contacts>10</max_contacts>\n    <surface>\n      <contact>\n        <ode>\n          <kp>1e+6</kp>  \x3c!-- Contact stiffness --\x3e\n          <kd>1e+3</kd>  \x3c!-- Damping coefficient --\x3e\n          <max_vel>100.0</max_vel>\n          <min_depth>0.001</min_depth>\n        </ode>\n      </contact>\n      <friction>\n        <ode>\n          <mu>1.0</mu>   \x3c!-- Coefficient of friction --\x3e\n          <mu2>1.0</mu2>\n          <fdir1>0 0 1</fdir1>\n        </ode>\n      </friction>\n    </surface>\n  </collision>\n</gazebo>\n')),(0,i.yg)("h2",{id:"performance-optimization"},"Performance Optimization"),(0,i.yg)("h3",{id:"gpu-acceleration"},"GPU Acceleration"),(0,i.yg)("p",null,"Ensure Gazebo uses GPU acceleration:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-bash"},'# Check OpenGL support\nglxinfo | grep "direct rendering"\n\n# Set environment variables for GPU acceleration\nexport MESA_GL_VERSION_OVERRIDE=3.3\nexport GZ_SIM_RESOURCE_PATH=/usr/share/gazebo-11/models\n')),(0,i.yg)("h3",{id:"optimizing-complex-models"},"Optimizing Complex Models"),(0,i.yg)("p",null,"For complex humanoid robots, optimize performance:"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("strong",{parentName:"li"},"Simplify collision meshes")," for physics simulation"),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("strong",{parentName:"li"},"Use Level of Detail (LOD)")," for rendering"),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("strong",{parentName:"li"},"Limit update rates")," for non-critical sensors"),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("strong",{parentName:"li"},"Reduce physics update rate")," if real-time performance is not required")),(0,i.yg)("h2",{id:"troubleshooting-common-issues"},"Troubleshooting Common Issues"),(0,i.yg)("h3",{id:"1-robot-falls-through-ground"},"1. Robot Falls Through Ground"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Check collision properties in URDF"),(0,i.yg)("li",{parentName:"ul"},"Verify physics parameters"),(0,i.yg)("li",{parentName:"ul"},"Ensure proper mass and inertia values")),(0,i.yg)("h3",{id:"2-unstable-walking-simulation"},"2. Unstable Walking Simulation"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Increase physics solver iterations"),(0,i.yg)("li",{parentName:"ul"},"Adjust contact parameters"),(0,i.yg)("li",{parentName:"ul"},"Verify joint limits and dynamics")),(0,i.yg)("h3",{id:"3-slow-performance"},"3. Slow Performance"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Reduce model complexity"),(0,i.yg)("li",{parentName:"ul"},"Lower sensor update rates"),(0,i.yg)("li",{parentName:"ul"},"Use simpler collision geometries")),(0,i.yg)("h2",{id:"best-practices-for-humanoid-robot-simulation"},"Best Practices for Humanoid Robot Simulation"),(0,i.yg)("h3",{id:"1-model-accuracy"},"1. Model Accuracy"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Use realistic mass and inertia values"),(0,i.yg)("li",{parentName:"ul"},"Accurate joint limits and dynamics"),(0,i.yg)("li",{parentName:"ul"},"Proper center of mass placement")),(0,i.yg)("h3",{id:"2-sensor-simulation"},"2. Sensor Simulation"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Include realistic noise models"),(0,i.yg)("li",{parentName:"ul"},"Match sensor specifications to real hardware"),(0,i.yg)("li",{parentName:"ul"},"Validate sensor data in simulation vs real")),(0,i.yg)("h3",{id:"3-environment-design"},"3. Environment Design"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Create environments similar to deployment scenarios"),(0,i.yg)("li",{parentName:"ul"},"Include various surfaces and obstacles"),(0,i.yg)("li",{parentName:"ul"},"Test edge cases and failure scenarios")),(0,i.yg)("h3",{id:"4-validation-process"},"4. Validation Process"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Compare simulation and real robot behavior"),(0,i.yg)("li",{parentName:"ul"},"Use simulation for regression testing"),(0,i.yg)("li",{parentName:"ul"},"Validate control algorithms before deployment")),(0,i.yg)("h2",{id:"hands-on-exercise"},"Hands-on Exercise"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},"Install Gazebo and verify the installation"),(0,i.yg)("li",{parentName:"ol"},"Create a simple world file with basic environment elements"),(0,i.yg)("li",{parentName:"ol"},"Configure physics parameters suitable for humanoid simulation"),(0,i.yg)("li",{parentName:"ol"},"Add lighting and basic obstacles to your world"),(0,i.yg)("li",{parentName:"ol"},"Launch your world and test basic functionality")),(0,i.yg)("h2",{id:"quiz-questions"},"Quiz Questions"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},"What are the key physics parameters that affect humanoid robot stability in Gazebo?"),(0,i.yg)("li",{parentName:"ol"},"How do you configure a camera sensor plugin in Gazebo for your humanoid robot?"),(0,i.yg)("li",{parentName:"ol"},"What are the best practices for optimizing Gazebo performance with complex humanoid models?"))))}g.isMDXComponent=!0},299:(e,n,a)=>{a.d(n,{A:()=>s});var o=a(6540);const i="interactiveLessonContainer_pdzt",t="lessonHeader_BiVh",r="lessonMeta_jdmH",l="lessonContent_Ivyb",s=({title:e,chapter:n,lesson:a,children:s})=>o.createElement("div",{className:i},o.createElement("div",{className:t},o.createElement("h1",null,e),o.createElement("div",{className:r},"Chapter ",n,", Lesson ",a)),o.createElement("div",{className:l},s))},5680:(e,n,a)=>{a.d(n,{xA:()=>c,yg:()=>p});var o=a(6540);function i(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function t(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter(function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable})),a.push.apply(a,o)}return a}function r(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?t(Object(a),!0).forEach(function(n){i(e,n,a[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):t(Object(a)).forEach(function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))})}return e}function l(e,n){if(null==e)return{};var a,o,i=function(e,n){if(null==e)return{};var a,o,i={},t=Object.keys(e);for(o=0;o<t.length;o++)a=t[o],n.indexOf(a)>=0||(i[a]=e[a]);return i}(e,n);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);for(o=0;o<t.length;o++)a=t[o],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var s=o.createContext({}),u=function(e){var n=o.useContext(s),a=n;return e&&(a="function"==typeof e?e(n):r(r({},n),e)),a},c=function(e){var n=u(e.components);return o.createElement(s.Provider,{value:n},e.children)},m="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},g=o.forwardRef(function(e,n){var a=e.components,i=e.mdxType,t=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),m=u(a),g=i,p=m["".concat(s,".").concat(g)]||m[g]||d[g]||t;return a?o.createElement(p,r(r({ref:n},c),{},{components:a})):o.createElement(p,r({ref:n},c))});function p(e,n){var a=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var t=a.length,r=new Array(t);r[0]=g;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l[m]="string"==typeof e?e:i,r[1]=l;for(var u=2;u<t;u++)r[u]=a[u];return o.createElement.apply(null,r)}return o.createElement.apply(null,a)}g.displayName="MDXCreateElement"}}]);