"use strict";(globalThis.webpackChunkhumanoid_robotic_book=globalThis.webpackChunkhumanoid_robotic_book||[]).push([[305],{299:(n,e,t)=>{t.d(e,{A:()=>p});var a=t(6540);const o="interactiveLessonContainer_pdzt",i="lessonHeader_BiVh",s="lessonMeta_jdmH",r="lessonContent_Ivyb",p=({title:n,chapter:e,lesson:t,children:p})=>a.createElement("div",{className:o},a.createElement("div",{className:i},a.createElement("h1",null,n),a.createElement("div",{className:s},"Chapter ",e,", Lesson ",t)),a.createElement("div",{className:r},p))},5513:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>r,default:()=>f,frontMatter:()=>s,metadata:()=>p,toc:()=>c});var a=t(8168),o=(t(6540),t(5680)),i=t(299);const s={sidebar_position:1},r=void 0,p={unversionedId:"chapter4/lesson3/bipedal-path-planning",id:"chapter4/lesson3/bipedal-path-planning",title:"bipedal-path-planning",description:"In this comprehensive lesson, you'll explore specialized path planning techniques for bipedal humanoid robots using the Navigation2 (Nav2) framework. Unlike wheeled robots, humanoid robots have unique locomotion constraints that require specialized planning algorithms to ensure stable, efficient, and safe navigation.",source:"@site/docs/chapter4/lesson3/bipedal-path-planning.mdx",sourceDirName:"chapter4/lesson3",slug:"/chapter4/lesson3/bipedal-path-planning",permalink:"/humanoid_robotic_book/docs/chapter4/lesson3/bipedal-path-planning",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"mySidebar",previous:{title:"hardware-accelerated-navigation",permalink:"/humanoid_robotic_book/docs/chapter4/lesson2/hardware-accelerated-navigation"},next:{title:"index",permalink:"/humanoid_robotic_book/docs/chapter5/"}},l={},c=[{value:"Introduction to Bipedal Path Planning",id:"introduction-to-bipedal-path-planning",level:2},{value:"Key Differences from Wheeled Navigation",id:"key-differences-from-wheeled-navigation",level:3},{value:"Navigation2 Architecture for Humanoid Robots",id:"navigation2-architecture-for-humanoid-robots",level:2},{value:"Nav2 Core Components",id:"nav2-core-components",level:3},{value:"Footstep Planning Algorithms",id:"footstep-planning-algorithms",level:2},{value:"A* for Footstep Planning",id:"a-for-footstep-planning",level:3},{value:"Footstep Planning with Balance Constraints",id:"footstep-planning-with-balance-constraints",level:3},{value:"Humanoid-Specific Path Smoothing",id:"humanoid-specific-path-smoothing",level:2},{value:"Cubic Spline Smoothing for Humanoid Paths",id:"cubic-spline-smoothing-for-humanoid-paths",level:3},{value:"ZMP-Based Path Planning",id:"zmp-based-path-planning",level:2},{value:"Zero Moment Point Path Planning",id:"zero-moment-point-path-planning",level:3},{value:"Integration with Navigation2",id:"integration-with-navigation2",level:2},{value:"Custom Nav2 Plugins for Humanoid Navigation",id:"custom-nav2-plugins-for-humanoid-navigation",level:3},{value:"Real-time Path Replanning",id:"real-time-path-replanning",level:2},{value:"Dynamic Obstacle Avoidance for Humanoid Robots",id:"dynamic-obstacle-avoidance-for-humanoid-robots",level:3},{value:"Performance Optimization and Best Practices",id:"performance-optimization-and-best-practices",level:2},{value:"Efficient Path Planning for Real-time Applications",id:"efficient-path-planning-for-real-time-applications",level:3},{value:"Best Practices for Bipedal Path Planning",id:"best-practices-for-bipedal-path-planning",level:2},{value:"1. Balance and Stability",id:"1-balance-and-stability",level:3},{value:"2. Terrain Adaptation",id:"2-terrain-adaptation",level:3},{value:"3. Human-like Navigation",id:"3-human-like-navigation",level:3},{value:"4. Computational Efficiency",id:"4-computational-efficiency",level:3},{value:"Troubleshooting Common Issues",id:"troubleshooting-common-issues",level:2},{value:"1. Path Oscillation",id:"1-path-oscillation",level:3},{value:"2. Balance Failures",id:"2-balance-failures",level:3},{value:"3. Performance Issues",id:"3-performance-issues",level:3},{value:"Hands-on Exercise",id:"hands-on-exercise",level:2},{value:"Quiz Questions",id:"quiz-questions",level:2}],_={toc:c},d="wrapper";function f({components:n,...e}){return(0,o.yg)(d,(0,a.A)({},_,e,{components:n,mdxType:"MDXLayout"}),(0,o.yg)(i.A,{title:"Bipedal Path Planning (Nav2)",chapter:4,lesson:3,mdxType:"InteractiveLesson"},(0,o.yg)("h1",{id:"bipedal-path-planning-nav2"},"Bipedal Path Planning (Nav2)"),(0,o.yg)("p",null,"In this comprehensive lesson, you'll explore specialized path planning techniques for bipedal humanoid robots using the Navigation2 (Nav2) framework. Unlike wheeled robots, humanoid robots have unique locomotion constraints that require specialized planning algorithms to ensure stable, efficient, and safe navigation."),(0,o.yg)("h2",{id:"introduction-to-bipedal-path-planning"},"Introduction to Bipedal Path Planning"),(0,o.yg)("p",null,"Bipedal path planning presents unique challenges compared to traditional mobile robots:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Dynamic Stability"),": Maintaining balance during locomotion"),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Footstep Planning"),": Planning where and how to place each foot"),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Center of Mass Management"),": Controlling the robot's balance point"),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Terrain Adaptability"),": Navigating various surfaces and obstacles"),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Human-like Movement"),": Achieving natural walking patterns")),(0,o.yg)("h3",{id:"key-differences-from-wheeled-navigation"},"Key Differences from Wheeled Navigation"),(0,o.yg)("ol",null,(0,o.yg)("li",{parentName:"ol"},(0,o.yg)("strong",{parentName:"li"},"Discrete Contact Points"),": Feet rather than continuous contact"),(0,o.yg)("li",{parentName:"ol"},(0,o.yg)("strong",{parentName:"li"},"Balance Constraints"),": Must maintain center of mass over support polygon"),(0,o.yg)("li",{parentName:"ol"},(0,o.yg)("strong",{parentName:"li"},"Step-by-Step Motion"),": Discrete step planning vs continuous motion"),(0,o.yg)("li",{parentName:"ol"},(0,o.yg)("strong",{parentName:"li"},"Dynamic Stability"),": Requires active balance control during movement"),(0,o.yg)("li",{parentName:"ol"},(0,o.yg)("strong",{parentName:"li"},"Terrain Sensitivity"),": More affected by ground irregularities")),(0,o.yg)("h2",{id:"navigation2-architecture-for-humanoid-robots"},"Navigation2 Architecture for Humanoid Robots"),(0,o.yg)("h3",{id:"nav2-core-components"},"Nav2 Core Components"),(0,o.yg)("p",null,"Navigation2 provides a flexible, behavior-tree-based architecture that can be adapted for humanoid navigation:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-python"},'import rclpy\nfrom rclpy.node import Node\nfrom nav2_behavior_tree.bt_controller import BehaviorTreeController\nfrom nav2_msgs.action import NavigateToPose\nfrom geometry_msgs.msg import PoseStamped\nimport math\n\nclass HumanoidNav2Node(Node):\n    def __init__(self):\n        super().__init__(\'humanoid_nav2_node\')\n\n        # Initialize Nav2 components\n        self.setup_nav2_components()\n\n        # Initialize humanoid-specific components\n        self.setup_bipedal_components()\n\n        # Create action client for navigation\n        self.nav_client = self.create_client(\n            NavigateToPose, \'navigate_to_pose\')\n\n        # Footstep planner\n        self.footstep_planner = FootstepPlanner()\n\n        # Balance controller\n        self.balance_controller = BalanceController()\n\n    def setup_nav2_components(self):\n        """Initialize standard Nav2 components"""\n        # Costmap for obstacle avoidance\n        # Global and local planners\n        # Controller for trajectory following\n        pass\n\n    def setup_bipedal_components(self):\n        """Initialize humanoid-specific navigation components"""\n        # Footstep planner\n        # Balance controller\n        # Walking pattern generator\n        # ZMP (Zero Moment Point) controller\n        pass\n\n    def plan_bipedal_path(self, start_pose, goal_pose):\n        """Plan a path considering bipedal constraints"""\n        # Use Nav2 global planner for high-level path\n        nav2_path = self.get_global_plan(start_pose, goal_pose)\n\n        # Convert to footstep plan\n        footstep_plan = self.footstep_planner.plan_footsteps(nav2_path)\n\n        # Validate balance constraints\n        balanced_plan = self.balance_controller.validate_balance(footstep_plan)\n\n        return balanced_plan\n\n    def execute_bipedal_navigation(self, goal_pose):\n        """Execute navigation with bipedal-specific control"""\n        # Plan footstep sequence\n        footstep_plan = self.plan_bipedal_path(self.get_robot_pose(), goal_pose)\n\n        # Execute step-by-step with balance control\n        for step in footstep_plan:\n            self.execute_footstep(step)\n            self.maintain_balance()\n\n            # Check for safety and adjust if needed\n            if not self.is_safe_to_continue():\n                return False\n\n        return True\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = HumanoidNav2Node()\n\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        node.get_logger().info(\'Shutting down\')\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n')),(0,o.yg)("h2",{id:"footstep-planning-algorithms"},"Footstep Planning Algorithms"),(0,o.yg)("h3",{id:"a-for-footstep-planning"},"A* for Footstep Planning"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-python"},'import numpy as np\nfrom scipy.spatial import KDTree\nimport heapq\n\nclass FootstepPlanner:\n    def __init__(self, step_size=0.3, max_step_width=0.4):\n        self.step_size = step_size  # Distance between consecutive steps\n        self.max_step_width = max_step_width  # Maximum lateral step width\n        self.costmap = None\n\n    def plan_footsteps(self, global_path):\n        """Plan footstep sequence from global path"""\n        if len(global_path) < 2:\n            return []\n\n        # Start with current robot position\n        footsteps = [global_path[0]]\n\n        # Plan footstep sequence\n        current_pos = global_path[0]\n        path_idx = 1\n\n        while path_idx < len(global_path):\n            # Find next valid footstep position\n            next_step = self.find_next_footstep(\n                current_pos, global_path[path_idx:], footsteps)\n\n            if next_step is None:\n                break  # Cannot find valid step\n\n            footsteps.append(next_step)\n            current_pos = next_step\n            path_idx = self.find_closest_path_index(current_pos, global_path, path_idx)\n\n        return footsteps\n\n    def find_next_footstep(self, current_pos, remaining_path, previous_steps):\n        """Find the next valid footstep position"""\n        # Search for valid step positions around the path\n        search_radius = self.step_size * 1.5\n\n        # Generate potential step positions\n        potential_steps = self.generate_potential_steps(current_pos, remaining_path[0])\n\n        # Evaluate each potential step\n        best_step = None\n        best_score = float(\'inf\')\n\n        for step in potential_steps:\n            if self.is_valid_footstep(step, previous_steps):\n                score = self.evaluate_footstep(step, remaining_path[0])\n                if score < best_score:\n                    best_score = score\n                    best_step = step\n\n        return best_step\n\n    def generate_potential_steps(self, current_pos, target_pos):\n        """Generate potential footstep positions around target"""\n        potential_steps = []\n\n        # Calculate direction toward target\n        dx = target_pos.pose.position.x - current_pos.pose.position.x\n        dy = target_pos.pose.position.y - current_pos.pose.position.y\n        distance = math.sqrt(dx*dx + dy*dy)\n\n        if distance == 0:\n            return potential_steps\n\n        # Normalize direction\n        dir_x = dx / distance\n        dir_y = dy / distance\n\n        # Generate steps in various directions\n        for step_dist in [self.step_size * 0.8, self.step_size, self.step_size * 1.2]:\n            for angle_offset in [-0.5, -0.25, 0, 0.25, 0.5]:  # Lateral variations\n                # Calculate step position\n                step_x = current_pos.pose.position.x + dir_x * step_dist\n                step_y = current_pos.pose.position.y + dir_y * step_dist\n\n                # Apply lateral offset\n                offset_x = -dir_y * angle_offset * self.max_step_width\n                offset_y = dir_x * angle_offset * self.max_step_width\n\n                step_x += offset_x\n                step_y += offset_y\n\n                # Create pose\n                step_pose = PoseStamped()\n                step_pose.pose.position.x = step_x\n                step_pose.pose.position.y = step_y\n                step_pose.pose.position.z = current_pos.pose.position.z\n\n                potential_steps.append(step_pose)\n\n        return potential_steps\n\n    def is_valid_footstep(self, step, previous_steps):\n        """Check if footstep is valid (collision-free, stable)"""\n        # Check collision with obstacles\n        if not self.is_collision_free(step):\n            return False\n\n        # Check balance constraints\n        if not self.is_balance_valid(step, previous_steps):\n            return False\n\n        return True\n\n    def is_collision_free(self, step):\n        """Check if step position is collision-free"""\n        # Check costmap at step position\n        x = int((step.pose.position.x - self.costmap_origin_x) / self.costmap_resolution)\n        y = int((step.pose.position.y - self.costmap_origin_y) / self.costmap_resolution)\n\n        if x < 0 or x >= self.costmap_width or y < 0 or y >= self.costmap_height:\n            return False\n\n        cost = self.costmap_data[y * self.costmap_width + x]\n        return cost < 50  # Threshold for valid step\n\n    def is_balance_valid(self, step, previous_steps):\n        """Check if step maintains balance"""\n        if len(previous_steps) < 1:\n            return True\n\n        # Calculate support polygon from current and previous foot positions\n        # For bipedal: check that COM projection is within triangle formed by feet\n        # This is a simplified check - real implementation would use ZMP or other criteria\n\n        # Check distance from previous step (should be within reasonable range)\n        prev_step = previous_steps[-1]\n        dx = step.pose.position.x - prev_step.pose.position.x\n        dy = step.pose.position.y - prev_step.pose.position.y\n        dist = math.sqrt(dx*dx + dy*dy)\n\n        return dist <= self.max_step_width * 2  # Reasonable step distance\n\n    def evaluate_footstep(self, step, target):\n        """Evaluate quality of footstep"""\n        # Distance to target\n        dx = step.pose.position.x - target.pose.position.x\n        dy = step.pose.position.y - target.pose.position.y\n        dist_to_target = math.sqrt(dx*dx + dy*dy)\n\n        # Smoothness penalty (deviation from straight path)\n        # Add other factors like terrain cost, etc.\n\n        return dist_to_target\n')),(0,o.yg)("h3",{id:"footstep-planning-with-balance-constraints"},"Footstep Planning with Balance Constraints"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-python"},'import numpy as np\nfrom geometry_msgs.msg import Point\n\nclass BalanceConstrainedFootstepPlanner:\n    def __init__(self):\n        self.zmp_margin = 0.05  # Safety margin for ZMP (meters)\n        self.max_step_height = 0.1  # Maximum step height (meters)\n        self.support_polygon = []\n\n    def plan_with_balance_constraints(self, start_pose, goal_pose, costmap):\n        """Plan footsteps with explicit balance constraints"""\n        # Initialize support polygon with starting foot positions\n        left_foot = self.calculate_left_foot_position(start_pose)\n        right_foot = self.calculate_right_foot_position(start_pose)\n\n        self.support_polygon = self.calculate_support_polygon(left_foot, right_foot)\n\n        # Plan footsteps using balance-aware A*\n        footsteps = self.balance_aware_astar(start_pose, goal_pose, costmap)\n\n        return footsteps\n\n    def balance_able_astar(self, start_pose, goal_pose, costmap):\n        """A* algorithm with balance constraints"""\n        # Priority queue: (cost, position, support_polygon)\n        open_set = [(0, start_pose, self.support_polygon)]\n        closed_set = set()\n\n        g_score = {self.pose_to_key(start_pose): 0}\n        came_from = {}\n\n        while open_set:\n            current_cost, current_pose, current_support = heapq.heappop(open_set)\n\n            # Check if we reached the goal\n            if self.is_at_goal(current_pose, goal_pose):\n                return self.reconstruct_path(came_from, current_pose)\n\n            current_key = self.pose_to_key(current_pose)\n            if current_key in closed_set:\n                continue\n\n            closed_set.add(current_key)\n\n            # Generate neighbor footsteps\n            neighbors = self.generate_balance_valid_neighbors(\n                current_pose, current_support, costmap)\n\n            for neighbor_pose, neighbor_support in neighbors:\n                neighbor_key = self.pose_to_key(neighbor_pose)\n\n                if neighbor_key in closed_set:\n                    continue\n\n                tentative_g_score = g_score[current_key] + self.step_cost(\n                    current_pose, neighbor_pose)\n\n                if neighbor_key not in g_score or tentative_g_score < g_score[neighbor_key]:\n                    came_from[neighbor_key] = current_key\n                    g_score[neighbor_key] = tentative_g_score\n                    f_score = tentative_g_score + self.heuristic(neighbor_pose, goal_pose)\n\n                    heapq.heappush(open_set, (f_score, neighbor_pose, neighbor_support))\n\n        return []  # No path found\n\n    def generate_balance_valid_neighbors(self, current_pose, current_support, costmap):\n        """Generate footstep neighbors that maintain balance"""\n        neighbors = []\n\n        # Generate potential step positions\n        potential_steps = self.generate_step_pattern(current_pose)\n\n        for step_pose in potential_steps:\n            if self.is_collision_free(step_pose, costmap):\n                # Calculate new support polygon after this step\n                new_support = self.update_support_polygon(\n                    current_support, current_pose, step_pose)\n\n                # Check if new support polygon maintains balance\n                if self.is_balance_maintained(new_support):\n                    neighbors.append((step_pose, new_support))\n\n        return neighbors\n\n    def is_balance_maintained(self, support_polygon):\n        """Check if support polygon can maintain balance"""\n        # Check if center of mass projection is within support polygon\n        # This would involve checking ZMP (Zero Moment Point) constraints\n        # For humanoid: ensure COM projection is within convex hull of feet\n\n        # Simplified check: ensure support polygon has reasonable area\n        area = self.calculate_polygon_area(support_polygon)\n        return area > 0.01  # Minimum support area threshold\n\n    def update_support_polygon(self, current_support, old_foot, new_foot):\n        """Update support polygon after a step"""\n        # For bipedal: when one foot moves, the support polygon changes\n        # This is a simplified model - real implementation would be more complex\n        updated_support = current_support.copy()\n        # Replace old foot position with new foot position\n        # Calculate new support polygon\n        return updated_support\n')),(0,o.yg)("h2",{id:"humanoid-specific-path-smoothing"},"Humanoid-Specific Path Smoothing"),(0,o.yg)("h3",{id:"cubic-spline-smoothing-for-humanoid-paths"},"Cubic Spline Smoothing for Humanoid Paths"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-python"},'import numpy as np\nfrom scipy.interpolate import CubicSpline\nimport math\n\nclass HumanoidPathSmoother:\n    def __init__(self):\n        self.smoothing_factor = 0.1\n        self.max_curvature = 0.5  # Maximum allowed curvature (1/m)\n\n    def smooth_path(self, raw_path):\n        """Smooth path for humanoid-friendly motion"""\n        if len(raw_path) < 3:\n            return raw_path\n\n        # Extract x, y coordinates\n        x_coords = [pose.pose.position.x for pose in raw_path]\n        y_coords = [pose.pose.position.y for pose in raw_path]\n\n        # Create parameterization based on cumulative distance\n        distances = [0]\n        for i in range(1, len(raw_path)):\n            dx = x_coords[i] - x_coords[i-1]\n            dy = y_coords[i] - y_coords[i-1]\n            distances.append(distances[-1] + math.sqrt(dx*dx + dy*dy))\n\n        # Create cubic splines\n        cs_x = CubicSpline(distances, x_coords, bc_type=\'natural\')\n        cs_y = CubicSpline(distances, y_coords, bc_type=\'natural\')\n\n        # Generate smooth path with appropriate resolution\n        smooth_path = []\n        total_distance = distances[-1]\n        step_size = 0.1  # 10cm steps for smooth humanoid motion\n\n        for d in np.arange(0, total_distance, step_size):\n            x = cs_x(d)\n            y = cs_y(d)\n\n            # Calculate orientation (tangent to path)\n            dx_dt = cs_x.derivative()(d)\n            dy_dt = cs_y.derivative()(d)\n            theta = math.atan2(dy_dt, dx_dt)\n\n            # Create pose\n            pose = PoseStamped()\n            pose.pose.position.x = x\n            pose.pose.position.y = y\n            pose.pose.position.z = raw_path[0].pose.position.z  # Maintain height\n\n            # Set orientation\n            from tf_transformations import quaternion_from_euler\n            quat = quaternion_from_euler(0, 0, theta)\n            pose.pose.orientation.x = quat[0]\n            pose.pose.orientation.y = quat[1]\n            pose.pose.orientation.z = quat[2]\n            pose.pose.orientation.w = quat[3]\n\n            smooth_path.append(pose)\n\n        return smooth_path\n\n    def apply_curvature_constraints(self, path):\n        """Apply curvature constraints for safe humanoid navigation"""\n        constrained_path = [path[0]]  # Start with first point\n\n        i = 0\n        while i < len(path) - 1:\n            current = path[i]\n            j = i + 1\n\n            # Find the furthest point that satisfies curvature constraints\n            while j < len(path):\n                if self.check_curvature_constraint(path[i], path[j]):\n                    j += 1\n                else:\n                    break\n\n            # Add the last valid point\n            if j > i + 1:\n                constrained_path.append(path[j - 1])\n                i = j - 1\n            else:\n                # If no valid point found, add the next point anyway\n                # (this might violate constraints but ensures progress)\n                constrained_path.append(path[i + 1])\n                i += 1\n\n        return constrained_path\n\n    def check_curvature_constraint(self, pose1, pose2):\n        """Check if segment between poses satisfies curvature constraints"""\n        dx = pose2.pose.position.x - pose1.pose.position.x\n        dy = pose2.pose.position.y - pose1.pose.position.y\n        distance = math.sqrt(dx*dx + dy*dy)\n\n        if distance < 0.01:  # Too close, avoid division by zero\n            return True\n\n        # Calculate curvature based on orientation change\n        # For a circular arc: curvature = 2*sin(angular_change/2) / distance\n        orientation1 = self.get_yaw_from_quaternion(pose1.pose.orientation)\n        orientation2 = self.get_yaw_from_quaternion(pose2.pose.orientation)\n\n        angular_change = abs(orientation2 - orientation1)\n        # Normalize to [-\u03c0, \u03c0]\n        while angular_change > math.pi:\n            angular_change -= 2 * math.pi\n        while angular_change < -math.pi:\n            angular_change += 2 * math.pi\n\n        # Approximate curvature\n        curvature = 2 * abs(math.sin(angular_change / 2)) / max(distance, 0.01)\n\n        return abs(curvature) <= self.max_curvature\n\n    def get_yaw_from_quaternion(self, quat):\n        """Extract yaw angle from quaternion"""\n        siny_cosp = 2 * (quat.w * quat.z + quat.x * quat.y)\n        cosy_cosp = 1 - 2 * (quat.y * quat.y + quat.z * quat.z)\n        return math.atan2(siny_cosp, cosy_cosp)\n')),(0,o.yg)("h2",{id:"zmp-based-path-planning"},"ZMP-Based Path Planning"),(0,o.yg)("h3",{id:"zero-moment-point-path-planning"},"Zero Moment Point Path Planning"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-python"},'import numpy as np\nfrom scipy.optimize import minimize\n\nclass ZMPPathPlanner:\n    def __init__(self):\n        self.com_height = 0.8  # Center of mass height (meters)\n        self.gravity = 9.81\n        self.zmp_margin = 0.05  # Safety margin (meters)\n\n    def plan_zmp_feasible_path(self, start_pose, goal_pose, support_regions):\n        """Plan path that maintains ZMP within support polygon"""\n        # Discretize the path\n        waypoints = self.discretize_path(start_pose, goal_pose)\n\n        # Optimize for ZMP feasibility\n        optimized_waypoints = self.optimize_for_zmp(waypoints, support_regions)\n\n        return optimized_waypoints\n\n    def discretize_path(self, start_pose, goal_pose):\n        """Create discrete waypoints along straight-line path"""\n        num_waypoints = 20  # Adjust based on path length\n        waypoints = []\n\n        dx = (goal_pose.pose.position.x - start_pose.pose.position.x) / (num_waypoints - 1)\n        dy = (goal_pose.pose.position.y - start_pose.pose.position.y) / (num_waypoints - 1)\n\n        for i in range(num_waypoints):\n            waypoint = PoseStamped()\n            waypoint.pose.position.x = start_pose.pose.position.x + i * dx\n            waypoint.pose.position.y = start_pose.pose.position.y + i * dy\n            waypoint.pose.position.z = start_pose.pose.position.z\n\n            waypoints.append(waypoint)\n\n        return waypoints\n\n    def optimize_for_zmp(self, waypoints, support_regions):\n        """Optimize waypoints to maintain ZMP feasibility"""\n        # Convert waypoints to optimization variables\n        # [x0, y0, x1, y1, ..., xn, yn]\n        initial_vars = []\n        for wp in waypoints:\n            initial_vars.extend([wp.pose.position.x, wp.pose.position.y])\n\n        # Define optimization function\n        def objective(vars):\n            total_cost = 0\n            for i in range(0, len(vars), 2):\n                # Deviation from original path\n                original_idx = i // 2\n                if original_idx < len(waypoints):\n                    orig_x = waypoints[original_idx].pose.position.x\n                    orig_y = waypoints[original_idx].pose.position.y\n                    total_cost += (vars[i] - orig_x)**2 + (vars[i+1] - orig_y)**2\n\n            return total_cost\n\n        # Define constraints\n        def zmp_constraint(vars):\n            """Ensure ZMP stays within support polygon at each step"""\n            constraints = []\n\n            for i in range(0, len(vars), 2):\n                x, y = vars[i], vars[i+1]\n\n                # Check if (x,y) is within support polygon\n                # This would involve checking if the point is inside the convex hull\n                # of the current foot positions\n                in_support = self.is_in_support_polygon(x, y, support_regions, i//2)\n\n                if in_support:\n                    constraints.append(1.0)  # Satisfied\n                else:\n                    constraints.append(-1.0)  # Violated\n\n            return np.array(constraints)\n\n        # Run optimization\n        result = minimize(\n            objective,\n            initial_vars,\n            method=\'SLSQP\',\n            constraints={\'type\': \'ineq\', \'fun\': zmp_constraint}\n        )\n\n        # Convert result back to waypoints\n        optimized_waypoints = []\n        for i in range(0, len(result.x), 2):\n            waypoint = PoseStamped()\n            waypoint.pose.position.x = result.x[i]\n            waypoint.pose.position.y = result.x[i+1]\n            waypoint.pose.position.z = waypoints[i//2].pose.position.z if i//2 < len(waypoints) else 0.0\n            optimized_waypoints.append(waypoint)\n\n        return optimized_waypoints\n\n    def is_in_support_polygon(self, x, y, support_regions, time_step):\n        """Check if point (x,y) is within support polygon at given time"""\n        # This would check if the ZMP projection is within the current support polygon\n        # formed by the feet positions\n        # Implementation would depend on the specific footstep plan\n        return True  # Placeholder\n')),(0,o.yg)("h2",{id:"integration-with-navigation2"},"Integration with Navigation2"),(0,o.yg)("h3",{id:"custom-nav2-plugins-for-humanoid-navigation"},"Custom Nav2 Plugins for Humanoid Navigation"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-python"},'# Custom Nav2 plugin for humanoid-specific path planning\nfrom nav2_core.global_planner import GlobalPlanner\nfrom nav2_core.local_planner import LocalPlanner\nfrom geometry_msgs.msg import PoseStamped, PoseWithCovarianceStamped\nfrom nav_msgs.msg import Path\nimport numpy as np\n\nclass HumanoidGlobalPlanner(GlobalPlanner):\n    def __init__(self):\n        super().__init__()\n        self.footstep_planner = FootstepPlanner()\n        self.balance_checker = BalanceConstrainedFootstepPlanner()\n\n    def create_plan(self, start, goal, planner_id=""):\n        """Create a bipedal-aware global plan"""\n        # Use standard A* or other algorithm for initial plan\n        raw_path = self.plan_standard_path(start, goal)\n\n        if not raw_path:\n            return Path()  # Empty path if no solution found\n\n        # Convert to footstep plan considering bipedal constraints\n        footstep_path = self.footstep_planner.plan_footsteps(raw_path)\n\n        # Validate with balance constraints\n        balanced_path = self.balance_checker.plan_with_balance_constraints(\n            start, goal, footstep_path)\n\n        # Convert to Nav2 Path message\n        nav2_path = Path()\n        nav2_path.header.frame_id = "map"\n        nav2_path.header.stamp = self.get_clock().now().to_msg()\n\n        for pose in balanced_path:\n            nav2_path.poses.append(pose.pose)\n\n        return nav2_path\n\n    def plan_standard_path(self, start, goal):\n        """Plan initial path using standard algorithms"""\n        # Implementation of standard path planning (A*, Dijkstra, etc.)\n        # This would typically use Nav2\'s costmap\n        pass\n\nclass HumanoidLocalPlanner(LocalPlanner):\n    def __init__(self):\n        super().__init__()\n        self.footstep_generator = FootstepGenerator()\n        self.balance_controller = BalanceController()\n\n    def setPlan(self, path):\n        """Set the global plan for local execution"""\n        self.global_path = path\n        self.footstep_generator.set_global_path(path)\n\n    def computeVelocityCommands(self, pose, velocity):\n        """Compute velocity commands for humanoid robot"""\n        # For bipedal robots, this might involve generating footstep plans\n        # rather than continuous velocity commands\n\n        # Calculate desired footstep based on current pose\n        desired_footstep = self.footstep_generator.get_next_footstep(pose)\n\n        # Generate walking pattern to reach desired footstep\n        walking_cmd = self.generate_walking_command(pose, desired_footstep)\n\n        # Ensure balance during execution\n        self.balance_controller.maintain_balance(pose, velocity)\n\n        return walking_cmd, True  # Return command and if goal reached\n\n    def generate_walking_command(self, current_pose, target_footstep):\n        """Generate walking command to reach target footstep"""\n        # This would generate specific walking pattern commands\n        # for the humanoid robot\'s walking controller\n        pass\n\n# Registration for Nav2\ndef register_plugins():\n    """Register custom humanoid navigation plugins"""\n    from nav2_core import Planner\n    from nav2_core import Controller\n\n    # Register custom planners and controllers\n    # This would typically be done in a plugin.xml file\n    pass\n')),(0,o.yg)("h2",{id:"real-time-path-replanning"},"Real-time Path Replanning"),(0,o.yg)("h3",{id:"dynamic-obstacle-avoidance-for-humanoid-robots"},"Dynamic Obstacle Avoidance for Humanoid Robots"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-python"},'import numpy as np\nfrom threading import Lock\nfrom sensor_msgs.msg import LaserScan\nfrom geometry_msgs.msg import Point\n\nclass DynamicHumanoidPathReplanner:\n    def __init__(self):\n        self.current_path = []\n        self.path_lock = Lock()\n        self.replan_threshold = 0.5  # Replan if obstacle within 0.5m\n        self.replan_rate = 1.0  # Replan at most once per second\n\n        self.last_replan_time = 0\n        self.footstep_planner = FootstepPlanner()\n\n    def update_with_sensor_data(self, scan_msg, robot_pose):\n        """Update path based on new sensor data"""\n        current_time = self.get_clock().now().nanoseconds / 1e9\n\n        # Check if replanning is needed\n        if (current_time - self.last_replan_time) < (1.0 / self.replan_rate):\n            return  # Too soon to replan\n\n        # Check for obstacles in path\n        if self.is_path_blocked(scan_msg, robot_pose):\n            # Plan new path avoiding obstacles\n            new_path = self.replan_around_obstacles(scan_msg, robot_pose)\n\n            if new_path:\n                with self.path_lock:\n                    self.current_path = new_path\n                    self.last_replan_time = current_time\n\n    def is_path_blocked(self, scan_msg, robot_pose):\n        """Check if current path is blocked by obstacles"""\n        # Convert path to local coordinates\n        local_path = self.transform_to_local_frame(self.current_path, robot_pose)\n\n        # Check each point in path against laser scan\n        for path_point in local_path:\n            if self.is_point_blocked(path_point, scan_msg):\n                return True\n\n        return False\n\n    def is_point_blocked(self, point, scan_msg):\n        """Check if a specific point is blocked by obstacles"""\n        # Calculate angle and distance from robot to point\n        angle = math.atan2(point.y, point.x)\n        distance = math.sqrt(point.x*point.x + point.y*point.y)\n\n        # Find corresponding laser beam\n        angle_increment = scan_msg.angle_increment\n        angle_min = scan_msg.angle_min\n\n        beam_index = int((angle - angle_min) / angle_increment)\n\n        if 0 <= beam_index < len(scan_msg.ranges):\n            range_reading = scan_msg.ranges[beam_index]\n\n            # If distance to obstacle is less than distance to point, it\'s blocked\n            return range_reading < distance and range_reading > scan_msg.range_min\n\n        return False\n\n    def replan_around_obstacles(self, scan_msg, robot_pose):\n        """Replan path to avoid detected obstacles"""\n        # Calculate current goal from path\n        if not self.current_path:\n            return None\n\n        goal = self.current_path[-1]  # Last point in current path\n\n        # Plan new path with obstacle inflation\n        self.footstep_planner.inflate_obstacles(scan_msg)\n\n        # Plan new footstep sequence\n        new_path = self.footstep_planner.plan_footsteps([robot_pose, goal])\n\n        return new_path\n')),(0,o.yg)("h2",{id:"performance-optimization-and-best-practices"},"Performance Optimization and Best Practices"),(0,o.yg)("h3",{id:"efficient-path-planning-for-real-time-applications"},"Efficient Path Planning for Real-time Applications"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-python"},'import time\nfrom functools import wraps\n\ndef timing_decorator(func):\n    """Decorator to measure execution time"""\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        start = time.time()\n        result = func(*args, **kwargs)\n        end = time.time()\n        print(f"{func.__name__} took {end - start:.4f} seconds")\n        return result\n    return wrapper\n\nclass OptimizedBipedalPathPlanner:\n    def __init__(self):\n        self.path_cache = {}\n        self.max_cache_size = 100\n\n    @timing_decorator\n    def plan_path_with_cache(self, start, goal):\n        """Plan path with caching for frequently requested paths"""\n        cache_key = self.create_cache_key(start, goal)\n\n        if cache_key in self.path_cache:\n            return self.path_cache[cache_key]\n\n        # Plan new path\n        path = self.plan_bipedal_path(start, goal)\n\n        # Add to cache\n        if len(self.path_cache) < self.max_cache_size:\n            self.path_cache[cache_key] = path\n\n        return path\n\n    def create_cache_key(self, start, goal):\n        """Create a hashable key for path caching"""\n        # Discretize positions to reduce cache size\n        start_key = (int(start.pose.position.x * 10), int(start.pose.position.y * 10))\n        goal_key = (int(goal.pose.position.x * 10), int(goal.pose.position.y * 10))\n        return (start_key, goal_key)\n\n    def plan_bipedal_path(self, start, goal):\n        """Efficient bipedal path planning implementation"""\n        # Use optimized algorithms and data structures\n        # Implement hierarchical planning for efficiency\n        # Use approximate methods when exact solutions aren\'t needed\n        pass\n\n    def hierarchical_path_planning(self, start, goal):\n        """Use hierarchical approach for efficiency"""\n        # High-level planning on coarse grid\n        high_level_path = self.plan_coarse_path(start, goal)\n\n        # Refine each segment with detailed footstep planning\n        detailed_path = []\n        for i in range(len(high_level_path) - 1):\n            segment = self.plan_detailed_segment(\n                high_level_path[i], high_level_path[i+1])\n            detailed_path.extend(segment[:-1])  # Exclude last point to avoid duplication\n\n        detailed_path.append(high_level_path[-1])  # Add final point\n        return detailed_path\n\n    def plan_coarse_path(self, start, goal):\n        """Plan path on coarse resolution grid"""\n        # Use standard path planning on downsampled map\n        pass\n\n    def plan_detailed_segment(self, start, end):\n        """Plan detailed footstep sequence for segment"""\n        # Plan footstep sequence between start and end points\n        pass\n')),(0,o.yg)("h2",{id:"best-practices-for-bipedal-path-planning"},"Best Practices for Bipedal Path Planning"),(0,o.yg)("h3",{id:"1-balance-and-stability"},"1. Balance and Stability"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"Always validate center of mass position relative to support polygon"),(0,o.yg)("li",{parentName:"ul"},"Use ZMP (Zero Moment Point) constraints for dynamic stability"),(0,o.yg)("li",{parentName:"ul"},"Plan conservative paths with adequate safety margins"),(0,o.yg)("li",{parentName:"ul"},"Consider walking speed effects on stability")),(0,o.yg)("h3",{id:"2-terrain-adaptation"},"2. Terrain Adaptation"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"Account for ground slope and unevenness"),(0,o.yg)("li",{parentName:"ul"},"Plan different step heights for stairs or curbs"),(0,o.yg)("li",{parentName:"ul"},"Consider surface friction and slipperiness"),(0,o.yg)("li",{parentName:"ul"},"Adapt step width and length based on terrain")),(0,o.yg)("h3",{id:"3-human-like-navigation"},"3. Human-like Navigation"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"Plan paths that avoid obstacles in a human-like manner"),(0,o.yg)("li",{parentName:"ul"},"Consider doorways, corridors, and human traffic patterns"),(0,o.yg)("li",{parentName:"ul"},"Plan for natural turning motions"),(0,o.yg)("li",{parentName:"ul"},"Maintain appropriate personal space from obstacles")),(0,o.yg)("h3",{id:"4-computational-efficiency"},"4. Computational Efficiency"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"Use hierarchical planning for large environments"),(0,o.yg)("li",{parentName:"ul"},"Implement path caching for frequently traveled routes"),(0,o.yg)("li",{parentName:"ul"},"Use approximate methods when exact solutions aren't critical"),(0,o.yg)("li",{parentName:"ul"},"Optimize data structures for fast collision checking")),(0,o.yg)("h2",{id:"troubleshooting-common-issues"},"Troubleshooting Common Issues"),(0,o.yg)("h3",{id:"1-path-oscillation"},"1. Path Oscillation"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"Increase smoothing parameters"),(0,o.yg)("li",{parentName:"ul"},"Use hysteresis in path re-planning"),(0,o.yg)("li",{parentName:"ul"},"Implement path following with tolerance")),(0,o.yg)("h3",{id:"2-balance-failures"},"2. Balance Failures"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"Increase support polygon margins"),(0,o.yg)("li",{parentName:"ul"},"Reduce walking speed in tight spaces"),(0,o.yg)("li",{parentName:"ul"},"Plan more conservative step sequences")),(0,o.yg)("h3",{id:"3-performance-issues"},"3. Performance Issues"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"Use coarser path discretization"),(0,o.yg)("li",{parentName:"ul"},"Implement multi-threading for planning"),(0,o.yg)("li",{parentName:"ul"},"Pre-compute static obstacle inflation")),(0,o.yg)("h2",{id:"hands-on-exercise"},"Hands-on Exercise"),(0,o.yg)("ol",null,(0,o.yg)("li",{parentName:"ol"},"Implement a basic footstep planner using the A* algorithm"),(0,o.yg)("li",{parentName:"ol"},"Add balance constraints to ensure stable walking"),(0,o.yg)("li",{parentName:"ol"},"Integrate with Navigation2's behavior tree system"),(0,o.yg)("li",{parentName:"ol"},"Test path planning in simulation with various obstacle configurations"),(0,o.yg)("li",{parentName:"ol"},"Validate that planned paths maintain dynamic stability")),(0,o.yg)("h2",{id:"quiz-questions"},"Quiz Questions"),(0,o.yg)("ol",null,(0,o.yg)("li",{parentName:"ol"},"What are the key differences between wheeled robot navigation and bipedal navigation?"),(0,o.yg)("li",{parentName:"ol"},"How does the Zero Moment Point (ZMP) concept apply to humanoid path planning?"),(0,o.yg)("li",{parentName:"ol"},"What are the main challenges in planning paths for bipedal humanoid robots?"))))}f.isMDXComponent=!0},5680:(n,e,t)=>{t.d(e,{xA:()=>c,yg:()=>u});var a=t(6540);function o(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function i(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(n);e&&(a=a.filter(function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable})),t.push.apply(t,a)}return t}function s(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?i(Object(t),!0).forEach(function(e){o(n,e,t[e])}):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach(function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))})}return n}function r(n,e){if(null==n)return{};var t,a,o=function(n,e){if(null==n)return{};var t,a,o={},i=Object.keys(n);for(a=0;a<i.length;a++)t=i[a],e.indexOf(t)>=0||(o[t]=n[t]);return o}(n,e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(n);for(a=0;a<i.length;a++)t=i[a],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(o[t]=n[t])}return o}var p=a.createContext({}),l=function(n){var e=a.useContext(p),t=e;return n&&(t="function"==typeof n?n(e):s(s({},e),n)),t},c=function(n){var e=l(n.components);return a.createElement(p.Provider,{value:e},n.children)},_="mdxType",d={inlineCode:"code",wrapper:function(n){var e=n.children;return a.createElement(a.Fragment,{},e)}},f=a.forwardRef(function(n,e){var t=n.components,o=n.mdxType,i=n.originalType,p=n.parentName,c=r(n,["components","mdxType","originalType","parentName"]),_=l(t),f=o,u=_["".concat(p,".").concat(f)]||_[f]||d[f]||i;return t?a.createElement(u,s(s({ref:e},c),{},{components:t})):a.createElement(u,s({ref:e},c))});function u(n,e){var t=arguments,o=e&&e.mdxType;if("string"==typeof n||o){var i=t.length,s=new Array(i);s[0]=f;var r={};for(var p in e)hasOwnProperty.call(e,p)&&(r[p]=e[p]);r.originalType=n,r[_]="string"==typeof n?n:o,s[1]=r;for(var l=2;l<i;l++)s[l]=t[l];return a.createElement.apply(null,s)}return a.createElement.apply(null,t)}f.displayName="MDXCreateElement"}}]);