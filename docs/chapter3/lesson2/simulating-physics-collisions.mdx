---
sidebar_position: 1
---

import InteractiveLesson from '@site/src/components/InteractiveLesson';

<InteractiveLesson title="Simulating Physics & Collisions" chapter={3} lesson={2}>

# Simulating Physics & Collisions

In this comprehensive lesson, you'll explore the physics simulation and collision detection systems that are crucial for realistic humanoid robot behavior in Gazebo. Understanding physics and collisions is essential for creating stable, responsive, and safe humanoid robots that can interact properly with their environment.

## Introduction to Physics Simulation in Gazebo

Physics simulation in Gazebo is powered by the Open Dynamics Engine (ODE), which provides realistic simulation of rigid body dynamics, collisions, and contacts. For humanoid robots, accurate physics simulation is critical for:

- **Stability**: Ensuring robots maintain balance during locomotion
- **Interaction**: Realistic responses to environmental contacts
- **Control Validation**: Testing control algorithms in realistic conditions
- **Safety**: Predicting robot behavior before real-world deployment

### Physics Engine Fundamentals

Gazebo's physics engine simulates the following physical phenomena:

1. **Rigid Body Dynamics**: Motion of solid objects under forces and torques
2. **Collision Detection**: Identifying when objects make contact
3. **Contact Response**: Computing forces during collisions
4. **Constraints**: Joint limitations and mechanical constraints
5. **Friction**: Surface interaction forces that oppose motion

## Physics Configuration for Humanoid Robots

### Global Physics Settings

The global physics configuration affects all objects in the simulation. For humanoid robots, these settings are particularly important:

```xml
<physics name="humanoid_physics" type="ode">
  <!-- Time stepping parameters -->
  <max_step_size>0.001</max_step_size>        <!-- Physics update rate (1ms = 1000Hz) -->
  <real_time_factor>1.0</real_time_factor>    <!-- Simulation speed relative to real time -->
  <real_time_update_rate>1000</real_time_update_rate>  <!-- Updates per second -->

  <!-- Gravity (Earth standard) -->
  <gravity>0 0 -9.8</gravity>

  <!-- ODE-specific parameters -->
  <ode>
    <solver>
      <type>quick</type>      <!-- QuickStep solver for stability -->
      <iters>100</iters>      <!-- More iterations for better stability -->
      <sor>1.3</sor>          <!-- Successive Over-Relaxation parameter -->
    </solver>

    <constraints>
      <cfm>0.000001</cfm>      <!-- Constraint Force Mixing -->
      <erp>0.1</erp>          <!-- Error Reduction Parameter -->
      <contact_max_correcting_vel>100.0</contact_max_correcting_vel>
      <contact_surface_layer>0.001</contact_surface_layer>
    </constraints>
  </ode>
</physics>
```

### Key Physics Parameters for Humanoid Stability

For humanoid robots, these parameters are crucial for stable simulation:

- **max_step_size**: Use 0.001s (1ms) or smaller for stable humanoid walking
- **solver iterations**: 100+ iterations for complex multi-link systems
- **CFM/ERP**: Low CFM and moderate ERP for stable constraints
- **contact parameters**: Proper surface layer and correction velocity

## Collision Detection and Response

### Collision Geometry Types

Gazebo supports several collision geometry types, each with different performance and accuracy characteristics:

#### 1. Primitive Shapes (Recommended for Physics)
```xml
<!-- Box collision -->
<collision name="body_collision">
  <geometry>
    <box>
      <size>0.3 0.2 0.4</size>
    </box>
  </geometry>
</collision>

<!-- Cylinder collision -->
<collision name="limb_collision">
  <geometry>
    <cylinder>
      <radius>0.05</radius>
      <length>0.3</length>
    </cylinder>
  </geometry>
</collision>

<!-- Sphere collision -->
<collision name="head_collision">
  <geometry>
    <sphere>
      <radius>0.1</radius>
    </sphere>
  </geometry>
</collision>
```

#### 2. Mesh Collisions (Use Sparingly)
```xml
<!-- Mesh collision (more accurate but slower) -->
<collision name="detailed_collision">
  <geometry>
    <mesh>
      <uri>model://humanoid_robot/meshes/detailed_shape.stl</uri>
    </mesh>
  </geometry>
</collision>
```

### Collision Properties for Humanoid Robots

Proper collision properties are essential for realistic interactions:

```xml
<gazebo reference="left_foot">
  <collision name="left_foot_collision">
    <max_contacts>10</max_contacts>
    <surface>
      <!-- Contact properties for stable walking -->
      <contact>
        <ode>
          <kp>1e+6</kp>        <!-- Contact stiffness (penalty parameter) -->
          <kd>1e+3</kd>        <!-- Damping coefficient -->
          <max_vel>100.0</max_vel>
          <min_depth>0.001</min_depth>  <!-- Penetration depth before contact force -->
        </ode>
      </contact>

      <!-- Friction properties -->
      <friction>
        <ode>
          <mu>1.0</mu>         <!-- Primary friction coefficient -->
          <mu2>1.0</mu2>       <!-- Secondary friction coefficient -->
          <fdir1>1 0 0</fdir1>  <!-- Friction direction (typically unused) -->
        </ode>
      </friction>

      <!-- Bounce properties -->
      <bounce>
        <restitution_coefficient>0.01</restitution_coefficient>
        <threshold>100000</threshold>
      </bounce>
    </surface>
  </collision>
</gazebo>
```

## Advanced Collision Handling

### Multi-Contact Simulation

For humanoid robots, especially for feet and hands, multiple contact points are important:

```xml
<gazebo reference="foot_link">
  <collision name="foot_collision">
    <max_contacts>20</max_contacts>  <!-- Allow multiple contact points -->
    <surface>
      <contact>
        <ode>
          <soft_cfm>0.000001</soft_cfm>
          <soft_erp>0.1</soft_erp>
          <kp>10000000</kp>
          <kd>1000</kd>
          <max_vel>100.0</max_vel>
          <min_depth>0.0001</min_depth>
        </ode>
      </contact>
      <friction>
        <ode>
          <mu>0.8</mu>    <!-- Good friction for walking -->
          <mu2>0.8</mu2>
        </ode>
      </friction>
    </surface>
  </collision>
</gazebo>
```

### Contact Sensors

For advanced control, you can add contact sensors to detect collisions:

```xml
<gazebo reference="left_foot">
  <sensor name="left_foot_contact" type="contact">
    <always_on>true</always_on>
    <update_rate>100</update_rate>
    <contact>
      <collision>left_foot_collision</collision>
    </contact>
    <plugin name="left_foot_contact_plugin" filename="libgazebo_ros_contact.so">
      <topic_name>left_foot/contacts</topic_name>
      <frame_name>left_foot</frame_name>
    </plugin>
  </sensor>
</gazebo>
```

## Physics Tuning for Different Scenarios

### Walking Simulation Parameters

For stable bipedal walking, use these tuned parameters:

```xml
<physics name="walking_physics" type="ode">
  <max_step_size>0.0005</max_step_size>    <!-- 2000Hz update rate -->
  <real_time_factor>0.5</real_time_factor> <!-- Allow slower than real-time for stability -->
  <ode>
    <solver>
      <iters>200</iters>                   <!-- High iteration count for stability -->
      <sor>1.0</sor>
    </solver>
    <constraints>
      <cfm>1e-5</cfm>
      <erp>0.2</erp>
    </constraints>
  </ode>
</physics>
```

### Manipulation Simulation Parameters

For manipulation tasks, prioritize accuracy over stability:

```xml
<physics name="manipulation_physics" type="ode">
  <max_step_size>0.001</max_step_size>
  <real_time_factor>1.0</real_time_factor>
  <ode>
    <solver>
      <iters>150</iters>
      <sor>1.2</sor>
    </solver>
    <constraints>
      <cfm>1e-6</cfm>        <!-- Very low CFM for precise contacts -->
      <erp>0.05</erp>        <!-- Low ERP for accurate contact forces -->
    </constraints>
  </ode>
</physics>
```

## Humanoid Robot Joint Configuration

### Joint Dynamics for Physics Simulation

Proper joint configuration is crucial for realistic physics behavior:

```xml
<!-- Example of a well-configured humanoid joint -->
<gazebo reference="left_knee">
  <joint name="left_knee_joint" type="revolute">
    <axis>
      <xyz>1 0 0</xyz>
      <limit>
        <lower>-2.0</lower>      <!-- Joint limits in radians -->
        <upper>0.5</upper>
        <effort>200</effort>     <!-- Maximum joint effort (N*m) -->
        <velocity>5</velocity>   <!-- Maximum joint velocity (rad/s) -->
      </limit>
      <dynamics>
        <damping>10.0</damping>    <!-- Damping coefficient -->
        <friction>1.0</friction>  <!-- Static friction -->
        <spring_reference>0</spring_reference>
        <spring_stiffness>0</spring_stiffness>
      </dynamics>
    </axis>
  </joint>
</gazebo>
```

### Joint Safety Limits

Add safety limits to prevent damage during simulation:

```xml
<gazebo reference="shoulder_joint">
  <joint name="left_shoulder_joint" type="revolute">
    <axis>
      <xyz>0 1 0</xyz>
      <limit>
        <lower>-1.57</lower>     <!-- -90 degrees -->
        <upper>1.57</upper>      <!-- +90 degrees -->
        <effort>150</effort>     <!-- Safety-limited effort -->
        <velocity>3</velocity>   <!-- Reasonable velocity limit -->
      </limit>
      <dynamics>
        <damping>5.0</damping>    <!-- Moderate damping -->
        <friction>0.5</friction> <!-- Low friction for smooth motion -->
      </dynamics>
    </axis>

    <!-- Safety plugin to enforce limits -->
    <physics>
      <ode>
        <limit>
          <cfm>0.0</cfm>
          <erp>0.8</erp>
        </limit>
        <motor>
          <cfm>0.0</cfm>
          <erp>0.8</erp>
        </motor>
      </ode>
    </physics>
  </joint>
</gazebo>
```

## Performance Optimization for Physics Simulation

### Level of Detail (LOD) for Physics

Use different collision complexities based on distance or importance:

```xml
<!-- Simplified collision for physics, detailed for rendering -->
<gazebo reference="complex_body_part">
  <!-- Simple collision for physics (fast) -->
  <collision name="physics_collision">
    <geometry>
      <box>
        <size>0.1 0.1 0.3</size>
      </box>
    </geometry>
  </collision>

  <!-- Detailed collision for accuracy (when needed) -->
  <collision name="detailed_collision">
    <geometry>
      <mesh>
        <uri>model://humanoid/meshes/detailed_collision.stl</uri>
      </mesh>
    </geometry>
  </collision>

  <!-- Visual geometry (for rendering) -->
  <visual name="visual">
    <geometry>
      <mesh>
        <uri>model://humanoid/meshes/visual_mesh.stl</uri>
      </mesh>
    </geometry>
  </visual>
</gazebo>
```

### Adaptive Physics Parameters

Adjust physics parameters based on simulation needs:

```xml
<!-- For different simulation phases -->
<physics name="stable_physics" type="ode">
  <max_step_size>0.001</max_step_size>
  <real_time_factor>0.5</real_time_factor>  <!-- Slower for stability -->
  <ode>
    <solver>
      <iters>150</iters>  <!-- High iterations for stability -->
    </solver>
  </ode>
</physics>

<physics name="fast_physics" type="ode">
  <max_step_size>0.002</max_step_size>
  <real_time_factor>1.0</real_time_factor>  <!-- Real-time speed -->
  <ode>
    <solver>
      <iters>50</iters>   <!-- Lower iterations for speed -->
    </solver>
  </ode>
</physics>
```

## Troubleshooting Physics Issues

### Common Physics Problems and Solutions

#### 1. Robot Falls Through Ground
```xml
<!-- Solution: Check collision properties -->
<gazebo reference="base_link">
  <collision name="ground_collision">
    <surface>
      <contact>
        <ode>
          <kp>1e+9</kp>        <!-- Very high stiffness -->
          <kd>1e+6</kd>        <!-- High damping -->
          <min_depth>0.0001</min_depth>  <!-- Small penetration allowed -->
        </ode>
      </contact>
    </surface>
  </collision>
</gazebo>
```

#### 2. Unstable Joint Oscillations
```xml
<!-- Solution: Increase damping and adjust solver -->
<gazebo reference="unstable_joint">
  <joint name="problematic_joint" type="revolute">
    <axis>
      <dynamics>
        <damping>50.0</damping>  <!-- High damping to reduce oscillations -->
        <friction>5.0</friction>
      </dynamics>
    </axis>
  </joint>
</gazebo>

<!-- Also increase solver iterations globally -->
<physics name="stable_physics" type="ode">
  <ode>
    <solver>
      <iters>200</iters>  <!-- More iterations for stability -->
    </solver>
  </ode>
</physics>
```

#### 3. Penetration Issues
```xml
<!-- Solution: Adjust contact parameters -->
<surface>
  <contact>
    <ode>
      <soft_cfm>1e-6</soft_cfm>    <!-- Very low CFM -->
      <soft_erp>0.9</soft_erp>     <!-- High ERP to correct errors quickly -->
      <kp>1e+8</kp>                <!-- High stiffness -->
      <kd>1e+5</kd>                <!-- Appropriate damping -->
    </ode>
  </contact>
</surface>
```

## Validation and Testing

### Physics Validation Techniques

1. **Static Balance Test**: Verify the robot can stand without falling
2. **Simple Motion Test**: Test basic joint movements for stability
3. **Contact Response Test**: Verify realistic responses to external forces
4. **Long-duration Test**: Run simulation for extended periods to check stability

### Performance Monitoring

Monitor physics performance with these metrics:

```bash
# Monitor Gazebo performance
gz stats

# Check physics update rate
gz topic -e /stats

# Monitor CPU usage
htop
```

## Best Practices for Humanoid Physics Simulation

### 1. Mass and Inertia Optimization
- Use realistic mass values based on actual robot specifications
- Ensure proper center of mass placement
- Verify inertia tensors are physically valid (positive definite)

### 2. Collision Geometry Strategy
- Use simple geometries for physics collisions
- Maintain appropriate number of contact points
- Balance accuracy with performance

### 3. Joint Parameter Tuning
- Set realistic joint limits based on hardware specifications
- Use appropriate damping values to prevent oscillations
- Configure effort and velocity limits for safety

### 4. Simulation Fidelity
- Match simulation parameters to real-world conditions
- Include realistic noise and disturbances
- Validate simulation results against physical tests

## Hands-on Exercise

1. Create a simple humanoid robot model with proper collision geometries
2. Configure physics parameters for stable standing
3. Test different joint configurations and observe stability
4. Add contact sensors and monitor contact forces
5. Validate the simulation by applying external forces

## Quiz Questions

1. What are the key physics parameters that affect humanoid robot stability?
2. How do contact parameters (CFM, ERP, stiffness, damping) influence robot behavior?
3. What is the recommended approach for collision geometry in humanoid robots?

</InteractiveLesson>