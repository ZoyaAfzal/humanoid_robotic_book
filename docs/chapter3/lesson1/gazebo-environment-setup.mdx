---
sidebar_position: 1
---

import InteractiveLesson from '@site/src/components/InteractiveLesson';

<InteractiveLesson title="Gazebo Environment Setup" chapter={3} lesson={1}>

# Gazebo Environment Setup

In this comprehensive lesson, you'll learn how to set up and configure Gazebo, the premier 3D robotics simulation environment. Gazebo provides realistic physics simulation, high-quality graphics, and sensor simulation capabilities essential for humanoid robot development and testing.

## Introduction to Gazebo

Gazebo is a powerful, open-source 3D robotics simulator that provides realistic physics simulation, high-quality graphics, and sensor simulation capabilities. For humanoid robotics, Gazebo serves as a digital twin environment where you can:

- Test robot behaviors in safe, controlled conditions
- Validate control algorithms before real-world deployment
- Simulate complex interactions with the environment
- Generate synthetic training data for AI models
- Perform regression testing for robot software

### Key Features of Gazebo

1. **Physics Simulation**: Accurate simulation of rigid body dynamics, collisions, and contacts
2. **Sensor Simulation**: Realistic simulation of cameras, LiDAR, IMU, and other sensors
3. **Environment Modeling**: Creation of complex indoor and outdoor environments
4. **ROS Integration**: Seamless integration with ROS and ROS 2 for robot control
5. **Plugin Architecture**: Extensible system for custom sensors, controllers, and behaviors

## Installing and Configuring Gazebo

### System Requirements

Before installing Gazebo, ensure your system meets the following requirements:

- **Operating System**: Ubuntu 20.04 LTS or 22.04 LTS (recommended)
- **Graphics**: OpenGL 2.1+ compatible GPU with dedicated VRAM
- **RAM**: Minimum 8GB (16GB recommended for complex simulations)
- **Storage**: 5GB+ free space for Gazebo and models
- **CPU**: Multi-core processor for optimal performance

### Installation Process

Gazebo can be installed in several ways depending on your needs:

#### Method 1: Package Installation (Recommended)

```bash
# Update package lists
sudo apt update

# Install Gazebo (for Ubuntu 22.04, installs Gazebo Garden)
sudo apt install gazebo

# Install ROS 2 Gazebo packages
sudo apt install ros-humble-gazebo-ros-pkgs ros-humble-gazebo-ros2-control

# Install additional useful packages
sudo apt install gazebo-plugin-base libgazebo-dev
```

#### Method 2: Using ROS 2 Integration

If you're using ROS 2 Humble Hawksbill, install the Gazebo integration packages:

```bash
# Install Gazebo simulation packages
sudo apt install ros-humble-gazebo-*
```

### Verification and Basic Setup

After installation, verify Gazebo is working:

```bash
# Launch Gazebo GUI
gazebo

# Or launch without GUI for headless simulation
gz sim -s

# Check Gazebo version
gz --version
```

## Gazebo World Creation and Configuration

### World File Structure

Gazebo worlds are defined using SDF (Simulation Description Format) files. Here's a basic world file structure:

```xml
<?xml version="1.0" ?>
<sdf version="1.7">
  <world name="humanoid_robot_world">
    <!-- Include default atmosphere -->
    <include>
      <uri>model://sun</uri>
    </include>

    <!-- Include ground plane -->
    <include>
      <uri>model://ground_plane</uri>
    </include>

    <!-- Lighting configuration -->
    <light name="sun" type="directional">
      <cast_shadows>true</cast_shadows>
      <pose>0 0 10 0 0 0</pose>
      <diffuse>0.8 0.8 0.8 1</diffuse>
      <specular>0.2 0.2 0.2 1</specular>
      <attenuation>
        <range>1000</range>
        <constant>0.9</constant>
        <linear>0.01</linear>
        <quadratic>0.001</quadratic>
      </attenuation>
      <direction>-0.5 0.1 -0.9</direction>
    </light>

    <!-- Physics engine configuration -->
    <physics name="1ms" type="ignored">
      <max_step_size>0.001</max_step_size>
      <real_time_factor>1</real_time_factor>
      <real_time_update_rate>1000</real_time_update_rate>
    </physics>

    <!-- Environment models -->
    <model name="table">
      <pose>2 0 0.5 0 0 0</pose>
      <include>
        <uri>model://table</uri>
      </include>
    </model>

    <!-- Your robot will be spawned here -->
  </world>
</sdf>
```

### Creating Custom Environments

For humanoid robot simulation, you'll often need custom environments. Here's a more complex world file for humanoid testing:

```xml
<?xml version="1.0" ?>
<sdf version="1.7">
  <world name="humanoid_test_world">
    <!-- Atmosphere -->
    <include>
      <uri>model://sun</uri>
    </include>

    <!-- Ground plane with texture -->
    <include>
      <uri>model://ground_plane</uri>
    </include>

    <!-- Lighting -->
    <light name="main_light" type="directional">
      <pose>0 0 10 0 0 0</pose>
      <diffuse>0.8 0.8 0.8 1</diffuse>
      <specular>0.2 0.2 0.2 1</specular>
      <direction>-0.5 0.1 -0.9</direction>
    </light>

    <!-- Physics configuration for humanoid simulation -->
    <physics name="humanoid_physics" type="ode">
      <max_step_size>0.001</max_step_size>
      <real_time_factor>1.0</real_time_factor>
      <real_time_update_rate>1000</real_time_update_rate>
      <gravity>0 0 -9.8</gravity>
      <ode>
        <solver>
          <type>quick</type>
          <iters>10</iters>
          <sor>1.3</sor>
        </solver>
        <constraints>
          <cfm>0.0</cfm>
          <erp>0.2</erp>
          <contact_max_correcting_vel>100.0</contact_max_correcting_vel>
          <contact_surface_layer>0.001</contact_surface_layer>
        </constraints>
      </ode>
    </physics>

    <!-- Environment obstacles for testing -->
    <model name="obstacle_1">
      <pose>-2 0 0.5 0 0 0</pose>
      <link name="link">
        <collision name="collision">
          <geometry>
            <box>
              <size>1 0.2 1</size>
            </box>
          </geometry>
        </collision>
        <visual name="visual">
          <geometry>
            <box>
              <size>1 0.2 1</size>
            </box>
          </geometry>
          <material>
            <ambient>0.5 0.5 0.5 1</ambient>
            <diffuse>0.8 0.8 0.8 1</diffuse>
          </material>
        </visual>
        <pose>0 0 0.5 0 0 0</pose>
      </link>
    </model>

    <!-- Indoor environment elements -->
    <model name="wall_1">
      <pose>0 -3 1 0 0 0</pose>
      <link name="wall_link">
        <collision name="wall_collision">
          <geometry>
            <box>
              <size>6 0.2 2</size>
            </box>
          </geometry>
        </collision>
        <visual name="wall_visual">
          <geometry>
            <box>
              <size>6 0.2 2</size>
            </box>
          </geometry>
          <material>
            <ambient>0.7 0.7 0.7 1</ambient>
            <diffuse>0.9 0.9 0.9 1</diffuse>
          </material>
        </visual>
      </link>
    </model>

    <!-- Furniture for realistic environment -->
    <include>
      <name>desk</name>
      <pose>3 2 0 0 0 0</pose>
      <uri>model://table</uri>
    </include>

    <include>
      <name>chair</name>
      <pose>3.5 2.5 0 0 0 1.57</pose>
      <uri>model://chair</uri>
    </include>
  </world>
</sdf>
```

## Gazebo Plugins for Humanoid Robots

### ROS 2 Control Integration

To integrate your humanoid robot with ROS 2, you'll need the Gazebo ROS 2 control plugin:

```xml
<!-- In your robot's URDF/Xacro file -->
<gazebo>
  <plugin filename="libgazebo_ros2_control.so" name="gazebo_ros2_control">
    <parameters>$(find your_robot_description)/config/your_robot_controllers.yaml</parameters>
    <robot_param>robot_description</robot_param>
    <robot_param_node>robot_state_publisher</robot_param_node>
  </plugin>
</gazebo>
```

### Sensor Plugins

Gazebo provides various sensor plugins for humanoid robots:

#### Camera Sensor Plugin

```xml
<gazebo reference="camera_link">
  <sensor name="camera" type="camera">
    <update_rate>30</update_rate>
    <camera name="head">
      <horizontal_fov>1.047</horizontal_fov>
      <image>
        <width>640</width>
        <height>480</height>
        <format>R8G8B8</format>
      </image>
      <clip>
        <near>0.1</near>
        <far>100</far>
      </clip>
    </camera>
    <plugin name="camera_controller" filename="libgazebo_ros_camera.so">
      <frame_name>camera_optical_frame</frame_name>
      <min_depth>0.1</min_depth>
      <max_depth>100</max_depth>
    </plugin>
  </sensor>
</gazebo>
```

#### IMU Sensor Plugin

```xml
<gazebo reference="imu_link">
  <sensor name="imu_sensor" type="imu">
    <always_on>true</always_on>
    <update_rate>100</update_rate>
    <visualize>true</visualize>
    <imu>
      <angular_velocity>
        <x>
          <noise type="gaussian">
            <mean>0.0</mean>
            <stddev>0.0017</stddev>
          </noise>
        </x>
        <y>
          <noise type="gaussian">
            <mean>0.0</mean>
            <stddev>0.0017</stddev>
          </noise>
        </y>
        <z>
          <noise type="gaussian">
            <mean>0.0</mean>
            <stddev>0.0017</stddev>
          </noise>
        </z>
      </angular_velocity>
      <linear_acceleration>
        <x>
          <noise type="gaussian">
            <mean>0.0</mean>
            <stddev>0.017</stddev>
          </noise>
        </x>
        <y>
          <noise type="gaussian">
            <mean>0.0</mean>
            <stddev>0.017</stddev>
          </noise>
        </y>
        <z>
          <noise type="gaussian">
            <mean>0.0</mean>
            <stddev>0.017</stddev>
          </noise>
        </z>
      </linear_acceleration>
    </imu>
  </sensor>
  <plugin name="imu_plugin" filename="libgazebo_ros_imu.so">
    <frame_name>imu_link</frame_name>
    <topic>imu/data</topic>
    <serviceName>imu/service</serviceName>
    <gaussianNoise>0.01</gaussianNoise>
    <updateRateHZ>100.0</updateRateHZ>
  </plugin>
</gazebo>
```

## Launching Gazebo with Your Robot

### Creating a Launch File

Here's a comprehensive launch file to start Gazebo with your humanoid robot:

```python
import os
from launch import LaunchDescription
from launch.actions import DeclareLaunchArgument, IncludeLaunchDescription, ExecuteProcess
from launch.conditions import IfCondition
from launch.launch_description_sources import PythonLaunchDescriptionSource
from launch.substitutions import LaunchConfiguration, PathJoinSubstitution
from launch_ros.actions import Node
from launch_ros.substitutions import FindPackageShare

def generate_launch_description():
    # Launch configuration variables
    use_sim_time = LaunchConfiguration('use_sim_time')
    use_rviz = LaunchConfiguration('use_rviz')
    world = LaunchConfiguration('world')

    # Declare launch arguments
    declare_use_sim_time_cmd = DeclareLaunchArgument(
        'use_sim_time',
        default_value='true',
        description='Use simulation (Gazebo) clock if true'
    )

    declare_use_rviz_cmd = DeclareLaunchArgument(
        'use_rviz',
        default_value='true',
        description='Whether to start RViz'
    )

    declare_world_cmd = DeclareLaunchArgument(
        'world',
        default_value=PathJoinSubstitution([
            FindPackageShare('your_robot_gazebo'),
            'worlds',
            'humanoid_test_world.sdf'
        ]),
        description='Choose one of the world files from `/your_robot_gazebo/worlds`'
    )

    # Start Gazebo with specified world
    start_gazebo_cmd = ExecuteProcess(
        cmd=['gz', 'sim', '-r', '-v4', LaunchConfiguration('world')],
        output='screen'
    )

    # Robot State Publisher
    robot_state_publisher_cmd = Node(
        package='robot_state_publisher',
        executable='robot_state_publisher',
        name='robot_state_publisher',
        output='screen',
        parameters=[{'use_sim_time': use_sim_time}]
    )

    # Spawn robot in Gazebo
    spawn_entity_cmd = Node(
        package='gazebo_ros',
        executable='spawn_entity.py',
        arguments=[
            '-topic', 'robot_description',
            '-entity', 'humanoid_robot',
            '-x', '0.0',
            '-y', '0.0',
            '-z', '1.0'
        ],
        output='screen'
    )

    # RViz node
    rviz_cmd = Node(
        package='rviz2',
        executable='rviz2',
        name='rviz2',
        output='screen',
        parameters=[{'use_sim_time': use_sim_time}],
        condition=IfCondition(use_rviz)
    )

    # Create launch description
    ld = LaunchDescription()

    # Add launch arguments
    ld.add_action(declare_use_sim_time_cmd)
    ld.add_action(declare_use_rviz_cmd)
    ld.add_action(declare_world_cmd)

    # Add launch actions
    ld.add_action(start_gazebo_cmd)
    ld.add_action(robot_state_publisher_cmd)
    ld.add_action(spawn_entity_cmd)
    ld.add_action(rviz_cmd)

    return ld
```

## Advanced Gazebo Configuration for Humanoid Robots

### Physics Tuning

For stable humanoid simulation, fine-tune physics parameters:

```xml
<physics name="humanoid_stable_physics" type="ode">
  <max_step_size>0.001</max_step_size>
  <real_time_factor>1.0</real_time_factor>
  <real_time_update_rate>1000</real_time_update_rate>
  <gravity>0 0 -9.8</gravity>
  <ode>
    <solver>
      <type>quick</type>
      <iters>100</iters>  <!-- More iterations for stability -->
      <sor>1.3</sor>
    </solver>
    <constraints>
      <cfm>0.000001</cfm>  <!-- Constraint Force Mixing -->
      <erp>0.1</erp>      <!-- Error Reduction Parameter -->
      <contact_max_correcting_vel>100.0</contact_max_correcting_vel>
      <contact_surface_layer>0.001</contact_surface_layer>
    </constraints>
  </ode>
</physics>
```

### Collision and Friction Settings

Proper collision and friction settings are crucial for humanoid walking:

```xml
<!-- In your robot's URDF -->
<gazebo reference="left_foot">
  <collision>
    <max_contacts>10</max_contacts>
    <surface>
      <contact>
        <ode>
          <kp>1e+6</kp>  <!-- Contact stiffness -->
          <kd>1e+3</kd>  <!-- Damping coefficient -->
          <max_vel>100.0</max_vel>
          <min_depth>0.001</min_depth>
        </ode>
      </contact>
      <friction>
        <ode>
          <mu>1.0</mu>   <!-- Coefficient of friction -->
          <mu2>1.0</mu2>
          <fdir1>0 0 1</fdir1>
        </ode>
      </friction>
    </surface>
  </collision>
</gazebo>
```

## Performance Optimization

### GPU Acceleration

Ensure Gazebo uses GPU acceleration:

```bash
# Check OpenGL support
glxinfo | grep "direct rendering"

# Set environment variables for GPU acceleration
export MESA_GL_VERSION_OVERRIDE=3.3
export GZ_SIM_RESOURCE_PATH=/usr/share/gazebo-11/models
```

### Optimizing Complex Models

For complex humanoid robots, optimize performance:

1. **Simplify collision meshes** for physics simulation
2. **Use Level of Detail (LOD)** for rendering
3. **Limit update rates** for non-critical sensors
4. **Reduce physics update rate** if real-time performance is not required

## Troubleshooting Common Issues

### 1. Robot Falls Through Ground
- Check collision properties in URDF
- Verify physics parameters
- Ensure proper mass and inertia values

### 2. Unstable Walking Simulation
- Increase physics solver iterations
- Adjust contact parameters
- Verify joint limits and dynamics

### 3. Slow Performance
- Reduce model complexity
- Lower sensor update rates
- Use simpler collision geometries

## Best Practices for Humanoid Robot Simulation

### 1. Model Accuracy
- Use realistic mass and inertia values
- Accurate joint limits and dynamics
- Proper center of mass placement

### 2. Sensor Simulation
- Include realistic noise models
- Match sensor specifications to real hardware
- Validate sensor data in simulation vs real

### 3. Environment Design
- Create environments similar to deployment scenarios
- Include various surfaces and obstacles
- Test edge cases and failure scenarios

### 4. Validation Process
- Compare simulation and real robot behavior
- Use simulation for regression testing
- Validate control algorithms before deployment

## Hands-on Exercise

1. Install Gazebo and verify the installation
2. Create a simple world file with basic environment elements
3. Configure physics parameters suitable for humanoid simulation
4. Add lighting and basic obstacles to your world
5. Launch your world and test basic functionality

## Quiz Questions

1. What are the key physics parameters that affect humanoid robot stability in Gazebo?
2. How do you configure a camera sensor plugin in Gazebo for your humanoid robot?
3. What are the best practices for optimizing Gazebo performance with complex humanoid models?

</InteractiveLesson>